

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>proto_db.queries &mdash; ProtoBase 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ProtoBase
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts.html">ProtoDB Fundamental Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook.html">ProtoDB Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook_traverse.html">Hierarchical and Graph Traversal with .traverse()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../performance.html">Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../storage_cloud.html">Cloud and Cluster Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vectors_arrow.html">Vectors and Arrow Bridge</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced_usage.html">Advanced Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced_usage.html#correlated-subqueries-with-select-many-lateral-join">Correlated Subqueries with .select_many() (LATERAL JOIN)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parallel_scans.html">Parallel Scans: Adaptive Chunking and Work-Stealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ProtoBase</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">proto_db.queries</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for proto_db.queries</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">QueryPlan</span><span class="p">,</span> <span class="n">AtomPointer</span><span class="p">,</span> <span class="n">DBObject</span><span class="p">,</span> <span class="n">AbstractTransaction</span><span class="p">,</span> <span class="n">DBCollections</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">ProtoValidationException</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.hybrid_executor</span><span class="w"> </span><span class="kn">import</span> <span class="n">HybridExecutor</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.db_access</span><span class="w"> </span><span class="kn">import</span> <span class="n">ObjectTransaction</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.dictionaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dictionary</span><span class="p">,</span> <span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">RepeatedKeysDictionary</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.sets</span><span class="w"> </span><span class="kn">import</span> <span class="n">Set</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">QueryContext</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lightweight context passed from the planner to indices while building plans.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        transaction: Optional transaction to be used during planning/execution.</span>
<span class="sd">        (Future fields like limit, offset can be added here.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">transaction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbstractTransaction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="QueryableIndex">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.QueryableIndex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">QueryableIndex</span><span class="p">(</span><span class="n">DBCollections</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract interface for pluggable indices that can contribute specialized</span>
<span class="sd">    query plans for particular terms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QueryableIndex.build_query_plan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.QueryableIndex.build_query_plan">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_query_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">:</span> <span class="s1">&#39;Term&#39;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">QueryContext</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a specialized QueryPlan for the given term if this index can</span>
<span class="sd">        handle it efficiently; otherwise return None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</div>


<span class="c1"># Executor for async operations</span>
<span class="n">max_workers</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span>
<span class="n">executor_pool</span> <span class="o">=</span> <span class="n">HybridExecutor</span><span class="p">(</span><span class="n">base_num_workers</span><span class="o">=</span><span class="n">max_workers</span> <span class="o">//</span> <span class="mi">5</span><span class="p">,</span> <span class="n">sync_multiplier</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">PROTODB_WARN_LINEAR_FALLBACK</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;PROTODB_WARN_LINEAR_FALLBACK&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">,</span> <span class="s1">&#39;False&#39;</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">,</span> <span class="s1">&#39;No&#39;</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Expression</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for all expression types used to filter or match records.</span>

<span class="sd">    Expressions represent logical conditions that can be applied to records, such as</span>
<span class="sd">    &quot;and&quot;, &quot;or&quot;, &quot;not&quot;, or specific comparisons (terms). Subclasses must implement</span>
<span class="sd">    the `match` method to define their behavior for evaluating a record.</span>

<span class="sd">    The `Expression` structure is highly flexible and supports composition of multiple</span>
<span class="sd">    logical operators for complex filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="n">expression</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile a nested list of expressions into an `Expression` object, flattening</span>
<span class="sd">        nested AND/OR trees into a canonical shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Expression</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">following_expression</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="c1"># Build NOT over the (possibly optimized) child</span>
                <span class="k">return</span> <span class="n">NotExpression</span><span class="p">(</span><span class="n">following_expression</span><span class="p">),</span> <span class="n">local_index</span>
            <span class="k">elif</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">first_operand</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="n">second_operand</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>

                <span class="c1"># Flatten AND expressions</span>
                <span class="n">new_terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="p">(</span><span class="n">first_operand</span><span class="p">,</span> <span class="n">second_operand</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
                        <span class="n">new_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">new_terms</span><span class="p">),</span> <span class="n">local_index</span>

            <span class="k">elif</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">first_operand</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="n">second_operand</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>

                <span class="c1"># Flatten OR expressions</span>
                <span class="n">new_terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="p">(</span><span class="n">first_operand</span><span class="p">,</span> <span class="n">second_operand</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
                        <span class="n">new_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">OrExpression</span><span class="p">(</span><span class="n">new_terms</span><span class="p">),</span> <span class="n">local_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Support nested sub-expressions and plain terms.</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span>
                <span class="c1"># If current token is a nested expression (list), compile it recursively</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">compiled</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                    <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">return</span> <span class="n">compiled</span><span class="p">,</span> <span class="n">local_index</span>
                <span class="c1"># Otherwise, it should be a plain term in prefix stream: [attr, op, value?]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">attr</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span>
                    <span class="n">op_token</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Invalid term at position </span><span class="si">{</span><span class="n">local_index</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">expression</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">operand</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">get_operator</span><span class="p">(</span><span class="n">op_token</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">operand</span><span class="o">.</span><span class="n">parameter_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">2</span>
                    <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">local_index</span>
                <span class="k">elif</span> <span class="n">operand</span><span class="o">.</span><span class="n">parameter_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Operand </span><span class="si">{</span><span class="n">op_token</span><span class="si">}</span><span class="s1"> expects binary term [attr, op, value]&#39;</span><span class="p">)</span>
                    <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">3</span>
                    <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">local_index</span>
                <span class="k">elif</span> <span class="n">operand</span><span class="o">.</span><span class="n">parameter_count</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lo</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="n">hi</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Operand </span><span class="si">{</span><span class="n">op_token</span><span class="si">}</span><span class="s1"> expects ternary term [attr, op, lo, hi]&#39;</span><span class="p">)</span>
                    <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">4</span>
                    <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)),</span> <span class="n">local_index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Unsupported parameter_count=</span><span class="si">{</span><span class="n">operand</span><span class="o">.</span><span class="n">parameter_count</span><span class="si">}</span><span class="s1"> for operator </span><span class="si">{</span><span class="n">op_token</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">default_and_expression</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
            <span class="n">new_expression</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">default_and_expression</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_expression</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">default_and_expression</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Flatten top-level implicit AND</span>
            <span class="n">final_terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">default_and_expression</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
                    <span class="n">final_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">final_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">final_terms</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">default_and_expression</span><span class="p">:</span>
            <span class="c1"># Single element: return it (already possibly flattened)</span>
            <span class="n">single_expr</span> <span class="o">=</span> <span class="n">default_and_expression</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">single_expr</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
                <span class="c1"># Ensure no nested AndExpression inside</span>
                <span class="n">flat_terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">single_expr</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
                        <span class="n">flat_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">flat_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">flat_terms</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">single_expr</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
                <span class="n">flat_terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">single_expr</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
                        <span class="n">flat_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">flat_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">OrExpression</span><span class="p">(</span><span class="n">flat_terms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">single_expr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Empty expression: return a neutral TrueTerm</span>
            <span class="k">return</span> <span class="n">TrueTerm</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Expression&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively optimize the expression tree by flattening nested AND/OR nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
            <span class="n">new_terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="n">optimized_term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Expression</span><span class="p">)</span> <span class="k">else</span> <span class="n">term</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimized_term</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
                    <span class="n">new_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">optimized_term</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">optimized_term</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">new_terms</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
            <span class="n">new_terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="n">optimized_term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Expression</span><span class="p">)</span> <span class="k">else</span> <span class="n">term</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimized_term</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
                    <span class="n">new_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">optimized_term</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">optimized_term</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">OrExpression</span><span class="p">(</span><span class="n">new_terms</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">NotExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">NotExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">negated_expression</span><span class="o">.</span><span class="n">optimize</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">filter_by_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Term</span><span class="p">):</span>
            <span class="n">atribute_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_attribute</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">atribute_alias</span> <span class="ow">in</span> <span class="n">alias</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TrueTerm</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
            <span class="n">new_operands</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="n">new_operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">filter_by_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">new_operands</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
            <span class="c1"># OR cannot be safely pushed down by alias without full context; return neutral TrueTerm</span>
            <span class="k">return</span> <span class="n">TrueTerm</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">NotExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">NotExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">negated_expression</span><span class="o">.</span><span class="n">filter_by_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;It&#39;s not possible to filter </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> expression by alias!&quot;</span>
            <span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matches a given record against specific criteria defined by the implementation.</span>

<span class="sd">        This method is abstract and must be implemented by a subclass to provide the</span>
<span class="sd">        logic for determining whether the provided record satisfies the required</span>
<span class="sd">        conditions. The exact nature of the matching depends on the subclass</span>
<span class="sd">        implementation.</span>

<span class="sd">        :param record: The record to be evaluated.</span>
<span class="sd">        :type record: Any</span>
<span class="sd">        :return: A boolean value indicating whether the record matches the criteria.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AndExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logical &#39;AND&#39; expression for combining multiple conditions.</span>

<span class="sd">    Evaluates as True only if all terms in the `terms` list evaluate to True for a record.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - terms (list[Expression]): Sub-expressions that must all evaluate as True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate if the given record matches all sub-term conditions.</span>

<span class="sd">        :param record: The input record to evaluate.</span>
<span class="sd">        :type record: Any</span>
<span class="sd">        :return: True if all terms match the record, False otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">OrExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NotExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="n">negated_expression</span><span class="p">:</span> <span class="n">Expression</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">negated_expression</span><span class="p">:</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negated_expression</span> <span class="o">=</span> <span class="n">negated_expression</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">negated_expression</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Operator</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for comparison operators.</span>

<span class="sd">    Operators define how a source value should be compared to another value</span>
<span class="sd">    to produce a boolean result. Subclasses implement different kinds of</span>
<span class="sd">    comparisons, such as equality, inequality, or inclusion.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - parameter_count (int): The number of parameters this operator expects for comparison.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_operator</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method to get an operator instance based on a string representation.</span>

<span class="sd">        This allows dynamic resolution of operator behavior (e.g., &#39;==&#39;, &#39;!=&#39;, &#39;contains&#39;)</span>
<span class="sd">        at runtime. If the operator string is not recognized, an exception is raised.</span>

<span class="sd">        :param string: The string representation of the operator (e.g., &#39;==&#39;, &#39;in&#39;).</span>
<span class="sd">        :type string: str</span>
<span class="sd">        :return: An instance of a subclass of `Operator`.</span>
<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;==&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Equal</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;!=&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NotEqual</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Greater</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GreaterOrEqual</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lower</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LowerOrEqual</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;contains&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Contains</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">In</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?T&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IsTrue</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?!T&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NotTrue</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?N&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IsNone</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?!N&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NotNone</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;between[]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Between</span><span class="p">(</span><span class="n">include_lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;between()&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Between</span><span class="p">(</span><span class="n">include_lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;between(]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Between</span><span class="p">(</span><span class="n">include_lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;between[)&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Between</span><span class="p">(</span><span class="n">include_lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;near[]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Near</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Unknown operator: </span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="s1">!&#39;</span>
            <span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is an abstract method that should be implemented in derived</span>
<span class="sd">        classes. It is designed to match the provided source against a specific</span>
<span class="sd">        value and return a result based on this matching process. The exact</span>
<span class="sd">        implementation and criteria of the match are dependent on the</span>
<span class="sd">        implementation in the subclass.</span>

<span class="sd">        :param source: The primary input against which the matching process</span>
<span class="sd">            will be performed. The exact nature of &#39;source&#39; depends on the</span>
<span class="sd">            implementation in the subclass.</span>
<span class="sd">        :param value: Optional value against which &#39;source&#39; will be matched.</span>
<span class="sd">            If not provided, the behavior may vary based on the subclass</span>
<span class="sd">            implementation.</span>
<span class="sd">        :return: The result of the matching process. The exact type and</span>
<span class="sd">            content of the returned value depend on the specific implementation</span>
<span class="sd">            in the subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Equal</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">==</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NotEqual</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">!=</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Greater</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&gt;</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GreaterOrEqual</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&gt;=</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Lower</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LowerOrEqual</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&lt;=</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Contains</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">source</span>


<span class="k">class</span><span class="w"> </span><span class="nc">In</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">IsTrue</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NotTrue</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">IsNone</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NotNone</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>


<div class="viewcode-block" id="Between">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.Between">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Between</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Range comparison operator with configurable bound inclusivity.</span>
<span class="sd">    `value` must be a tuple (lo, hi).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<div class="viewcode-block" id="Between.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.Between.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">include_upper</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span> <span class="o">=</span> <span class="n">include_lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">=</span> <span class="n">include_upper</span></div>


<div class="viewcode-block" id="Between.match">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.Between.match">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">hi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># If lo &gt; hi, consider empty set (no match)</span>
            <span class="k">if</span> <span class="n">lo</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Lower bound</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Upper bound</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&gt;=</span> <span class="n">hi</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Non-comparable types -&gt; no match</span>
            <span class="k">return</span> <span class="kc">False</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">Near</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Similarity threshold operator for vector fields.</span>
<span class="sd">    Usage in Expression.compile: [&#39;field&#39;, &#39;near[]&#39;, query_vector, threshold]</span>
<span class="sd">    - value is treated as a tuple (query_vector, threshold)</span>
<span class="sd">    - metric defaults to cosine</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;cosine&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">query_vec</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Accept both plain lists and Vector objects</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.vectors</span><span class="w"> </span><span class="kn">import</span> <span class="n">Vector</span><span class="p">,</span> <span class="n">cosine_similarity</span><span class="p">,</span> <span class="n">l2_distance</span>
            <span class="c1"># Extract raw data for source</span>
            <span class="n">src</span> <span class="o">=</span> <span class="n">source</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
                <span class="n">src_iter</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">src_iter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;cosine&#39;</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span><span class="n">src_iter</span><span class="p">,</span> <span class="n">query_vec</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_vec</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="k">else</span> <span class="n">query_vec</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;l2&#39;</span><span class="p">:</span>
                <span class="c1"># For l2, interpret threshold as max distance</span>
                <span class="c1"># Near should be distance &lt;= threshold</span>
                <span class="c1"># Use -distance as score if needed elsewhere</span>
                <span class="c1"># Compute distance</span>
                <span class="c1"># Reuse cosine helpers module for l2</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">.vectors</span><span class="w"> </span><span class="kn">import</span> <span class="n">l2_distance</span> <span class="k">as</span> <span class="n">_l2</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">_l2</span><span class="p">(</span><span class="n">src_iter</span><span class="p">,</span> <span class="n">query_vec</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_vec</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="k">else</span> <span class="n">query_vec</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Term</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="n">target_attribute</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">operation</span><span class="p">:</span> <span class="n">Operator</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">object</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">operation</span><span class="p">:</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_attribute</span> <span class="o">=</span> <span class="n">target_attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operation</span> <span class="o">=</span> <span class="n">operation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="c1"># Support dotted-paths and dict/DBObject records</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">resolve</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cur</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">cur</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">cur</span>
        <span class="n">source_value</span> <span class="o">=</span> <span class="n">resolve</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_attribute</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operation</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">source_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TrueTerm</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">FalseTerm</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="ListPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ListPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a QueryPlan from a python list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_list</span><span class="p">:</span> <span class="nb">list</span>

<div class="viewcode-block" id="ListPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">base_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_list</span> <span class="o">=</span> <span class="n">base_list</span></div>


<div class="viewcode-block" id="ListPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DBCollections</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.lists</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> <span class="k">as</span> <span class="n">_List</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_List</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_list</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">append_last</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="ListPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="VectorSearchPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.VectorSearchPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VectorSearchPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Query plan that delegates to a vector index implementing a search API.</span>
<span class="sd">    It supports either top-k or threshold (range) searches.</span>
<span class="sd">    The index is expected to either return Atom objects directly or (id, score) pairs.</span>
<span class="sd">    If pairs are returned, an id→object map can be provided via index._id_to_obj.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">query_vector</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_vector</span> <span class="o">=</span> <span class="n">query_vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>

<div class="viewcode-block" id="VectorSearchPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.VectorSearchPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DBCollections</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.lists</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> <span class="k">as</span> <span class="n">_List</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_List</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fallback to range_search when threshold is provided</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">range_search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">id_map</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;_id_to_obj&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Normalize to objects</span>
        <span class="k">if</span> <span class="n">results</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">objs</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">objs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">rid</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">id_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rid</span> <span class="ow">in</span> <span class="n">id_map</span><span class="p">:</span>
                        <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_map</span><span class="p">[</span><span class="n">rid</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># If rid is already an Atom/record, use it</span>
                        <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rid</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">continue</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">append_last</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="VectorSearchPlan.get_cardinality_estimate">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.VectorSearchPlan.get_cardinality_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cardinality_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="c1"># Heuristic: 1% of base, if available</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">base_cnt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">count</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">base_cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base_cnt</span> <span class="o">//</span> <span class="mi">100</span><span class="p">)</span> <span class="k">if</span> <span class="n">base_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">100</span></div>


<div class="viewcode-block" id="VectorSearchPlan.get_cost_estimate">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.VectorSearchPlan.get_cost_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cost_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># Cheaper than full scan, more expensive than exact key lookup</span>
        <span class="k">return</span> <span class="mf">25.0</span></div>


<div class="viewcode-block" id="VectorSearchPlan.explain">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.VectorSearchPlan.explain">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">idx_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;field_name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qp</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;k=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qp</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;threshold=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;plan_type&#39;</span><span class="p">:</span> <span class="s1">&#39;VectorSearchPlan&#39;</span><span class="p">,</span>
            <span class="s1">&#39;index_used&#39;</span><span class="p">:</span> <span class="n">idx_name</span><span class="p">,</span>
            <span class="s1">&#39;lookup_type&#39;</span><span class="p">:</span> <span class="s1">&#39;ANN Search&#39;</span><span class="p">,</span>
            <span class="s1">&#39;query_params&#39;</span><span class="p">:</span> <span class="n">qp</span><span class="p">,</span>
            <span class="s1">&#39;estimated_cardinality&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cardinality_estimate</span><span class="p">(),</span>
            <span class="s1">&#39;estimated_cost&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cost_estimate</span><span class="p">(),</span>
        <span class="p">}</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">IndexedQueryPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IndexedQueryPlan is a specialized version of QueryPlan.</span>

<span class="sd">    It provides functionality for creating and managing indexed query plans</span>
<span class="sd">    that optimize query execution based on indexed data sources. This class</span>
<span class="sd">    extends the base functionality of QueryPlan to incorporate the use of</span>
<span class="sd">    indices in query operations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="nb">object</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Lazy import to avoid circular dependency; only used if someone constructs</span>
            <span class="c1"># an IndexedQueryPlan without providing indexes.</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.dictionaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dictionary</span> <span class="k">as</span> <span class="n">_Dictionary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="n">_Dictionary</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DBCollections</span><span class="p">:</span>
        <span class="c1"># Delegate execution to the underlying plan; indexes are only metadata for optimization</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.lists</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> <span class="k">as</span> <span class="n">_List</span>
            <span class="k">return</span> <span class="n">_List</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IndexedQueryPlan</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an index to the database for optimizing query performance on specified columns. This method</span>
<span class="sd">        creates a new index with the given name on the columns specified in the list. Indexing can</span>
<span class="sd">        significantly improve the efficiency of certain queries, particularly for large datasets.</span>

<span class="sd">        :param field_name: field the index will be created on</span>
<span class="sd">        :return: An indexed query plan that contains details of the created index and its application</span>
<span class="sd">                 to the underlying query structure.</span>
<span class="sd">        :rtype: IndexedQueryPlan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">field_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Reindex the current content on the added field</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.dictionaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">RepeatedKeysDictionary</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">RepeatedKeysDictionary</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">field_name</span><span class="p">):</span>
                <span class="c1"># Use native key types (no string conversion)</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">new_index</span><span class="p">),</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update_indexes_on_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">removed_record</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IndexedQueryPlan</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update indexes when specific data is removed from a collection or database.</span>

<span class="sd">        This function updates the internal indexes to maintain consistency</span>
<span class="sd">        after the specified data is removed. It ensures that subsequent</span>
<span class="sd">        queries reflect the correct indexed structure.</span>

<span class="sd">        :param removed_record: The data item that was removed, for which the</span>
<span class="sd">            indexes need to be updated.</span>
<span class="sd">        :return: An updated query plan reflecting the state of indexes</span>
<span class="sd">            after the removal.</span>
<span class="sd">        :rtype: IndexedQueryPlan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
            <span class="c1"># index is expected to support remove_record_at(key, record)</span>
            <span class="k">if</span> <span class="n">removed_record</span><span class="p">[</span><span class="n">field_name</span><span class="p">]:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">removed_record</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>
                <span class="n">new_indexes</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">remove_record_at</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">removed_record</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">new_indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update_indexes_on_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">added_record</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IndexedQueryPlan</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the indexed query plan when an item is added to the dataset.</span>

<span class="sd">        The method ensures that the internal indexes are recalibrated after</span>
<span class="sd">        removing any existing data that would conflict with the new item&#39;s</span>
<span class="sd">        location or plan alignment in the indexed structure. It recalculates</span>
<span class="sd">        and returns the updated query plan that reflects the modifications.</span>

<span class="sd">        :param added_record: the added data.</span>
<span class="sd">        :return: The updated IndexedQueryPlan object after modification to</span>
<span class="sd">            reflect changes caused by the addition operation.</span>
<span class="sd">        :rtype: IndexedQueryPlan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">RepeatedKeysDictionary</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">added_record</span><span class="p">[</span><span class="n">field_name</span><span class="p">]:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">added_record</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>
                <span class="n">new_indexes</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">added_record</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">new_indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">position_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">field_name</span><span class="p">):</span>
            <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_ok</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="c1"># use same ordering as DictionaryItem</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">.dictionaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">DictionaryItem</span> <span class="k">as</span> <span class="n">_DI</span>
                <span class="k">return</span> <span class="n">_DI</span><span class="o">.</span><span class="n">_order_key</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">target_ok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

                <span class="n">item</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">item_ok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">item_ok</span> <span class="o">==</span> <span class="n">target_ok</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">center</span>

                <span class="k">if</span> <span class="n">item_ok</span> <span class="o">&gt;</span> <span class="n">target_ok</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;No index on field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s1">!&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">yield_from_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_greater_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_from_index</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_greater_or_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_from_index</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">field_name</span><span class="p">):</span>
            <span class="n">idx_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="c1"># Native key match without string conversion</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;No index on field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s1">!&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">yield_up_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index_up_to</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">count</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">index_up_to</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_lower_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">idx_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Exclusive: do not include the bucket equal to value</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_up_to_index</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_lower_or_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">idx_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Inclusive: if exact match at position, include it by advancing one</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_up_to_index</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">lo</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">include_lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">include_upper</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate records whose indexed key is within [lo, hi] with bound inclusivity flags.</span>
<span class="sd">        Uses native-type comparisons; avoids converting keys/values to strings.</span>
<span class="sd">        Performs a binary search to the first matching index, then a sequential scan until hi.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">field_name</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;No index on field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
        <span class="n">idx_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">.dictionaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">DictionaryItem</span> <span class="k">as</span> <span class="n">_DI</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_ok</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_DI</span><span class="o">.</span><span class="n">_order_key</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">count</span>
        <span class="c1"># Binary search lower bound position</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">target_ok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">center</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">iok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">iok</span> <span class="o">&gt;=</span> <span class="n">target_ok</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">center</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Adjust for exclusivity on lower bound</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">include_lower</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">lo</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Sequential scan until upper bound</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="n">hi_ok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">key_ok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># Stop if beyond upper bound (respect inclusivity)</span>
            <span class="k">if</span> <span class="n">key_ok</span> <span class="o">&gt;</span> <span class="n">hi_ok</span> <span class="ow">or</span> <span class="p">(</span><span class="n">key_ok</span> <span class="o">==</span> <span class="n">hi_ok</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_upper</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">hi</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="c1"># Skip items below lower bound (in case of edge adjustments)</span>
            <span class="k">if</span> <span class="n">key_ok</span> <span class="o">&lt;</span> <span class="n">target_ok</span> <span class="ow">or</span> <span class="p">(</span><span class="n">key_ok</span> <span class="o">==</span> <span class="n">target_ok</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_lower</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">lo</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>


<span class="k">class</span><span class="w"> </span><span class="nc">IndexedSearchPlan</span><span class="p">(</span><span class="n">IndexedQueryPlan</span><span class="p">):</span>
    <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">:</span> <span class="n">Dictionary</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">field_to_scan</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;The field to scan should be specified!&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">operator</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;The operator should be specified!&#39;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span> <span class="o">=</span> <span class="n">field_to_scan</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="p">(</span>
                <span class="n">Lower</span><span class="p">,</span> <span class="n">LowerOrEqual</span><span class="p">,</span> <span class="n">Equal</span><span class="p">,</span> <span class="n">GreaterOrEqual</span><span class="p">,</span> <span class="n">Greater</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;The operator is not valid (</span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s1">)!&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Equal</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Greater</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_greater_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">GreaterOrEqual</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_greater_or_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Lower</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lower_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">LowerOrEqual</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lower_or_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">IndexedSearchPlan</span><span class="p">(</span>
            <span class="n">field_to_scan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast count leveraging indexes when possible.</span>
<span class="sd">        - For equality over an indexed field, return the set count directly.</span>
<span class="sd">        - Otherwise, fallback to executing and counting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Equal</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">):</span>
                <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>
                <span class="c1"># Try native-key lookup by using get_at for direct access</span>
                <span class="n">value_set</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="n">value_set</span><span class="o">.</span><span class="n">count</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># On any unexpected shape, fallback to generic count</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_references</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">frozenset</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a frozenset of stable references (preferably AtomPointer.hash()) for records</span>
<span class="sd">        matching this indexed predicate, without materializing full objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">refs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">)):</span>
                <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span>
            <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_ref_of</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="s1">&#39;atom_pointer&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">rec</span><span class="o">.</span><span class="n">atom_pointer</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">atom_pointer</span><span class="o">.</span><span class="n">hash</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">hash</span><span class="p">()</span>  <span class="c1"># custom wrapper may implement</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span>
        <span class="c1"># Build from index buckets</span>
        <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="n">refs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_ref_of</span><span class="p">(</span><span class="n">rec</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">refs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_cardinality_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exact O(1) estimate for equality lookups using the underlying index bucket size.</span>
<span class="sd">        Returns 0 when the key is absent or index is unavailable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Equal</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">):</span>
                <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>
                <span class="n">value_set</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_set</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="k">if</span> <span class="n">value_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># Fallback to base class heuristic</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_cardinality_estimate</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_cost_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equality lookup on an index is very cheap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1"># Detailed explain for indexed equality lookup</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;plan_type&#39;</span><span class="p">:</span> <span class="s1">&#39;IndexedSearchPlan&#39;</span><span class="p">,</span>
            <span class="s1">&#39;index_used&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span>
            <span class="s1">&#39;lookup_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Exact (Equality)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="s1">&#39;estimated_cardinality&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cardinality_estimate</span><span class="p">(),</span>
            <span class="s1">&#39;estimated_cost&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cost_estimate</span><span class="p">(),</span>
        <span class="p">}</span>



<span class="k">class</span><span class="w"> </span><span class="nc">OrMerge</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
    <span class="n">or_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">or_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span> <span class="o">=</span> <span class="n">or_queries</span> <span class="ow">or</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute all sub-queries and yield the concatenated union of results without de-duplication.</span>
<span class="sd">        De-duplication is responsibility of count() or higher-level consumers when needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">rec</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">OrMerge</span><span class="p">(</span>
            <span class="n">or_queries</span><span class="o">=</span><span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span><span class="p">],</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count unique records across sub-queries.</span>
<span class="sd">        Prefer fast path with get_references()/keys_iterator() when available; otherwise fall back to hashing</span>
<span class="sd">        materialized items from execute().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Try fast path using get_references when present</span>
        <span class="n">uniq</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">any_fast</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s1">&#39;get_references&#39;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">refs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s1">&#39;get_references&#39;</span><span class="p">)()</span>
                    <span class="k">if</span> <span class="n">refs</span><span class="p">:</span>
                        <span class="n">any_fast</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">uniq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">refs</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="c1"># Try keys_iterator if defined</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s1">&#39;keys_iterator&#39;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">keys_iterator</span><span class="p">():</span>
                        <span class="n">uniq</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                    <span class="n">any_fast</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">if</span> <span class="n">any_fast</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq</span><span class="p">)</span>
        <span class="c1"># Fallback: materialize and hash</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_ref_of</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="s1">&#39;atom_pointer&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">atom_pointer</span><span class="o">.</span><span class="n">hash</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">hash</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">uniq</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_ref_of</span><span class="p">(</span><span class="n">rec</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;plan_type&#39;</span><span class="p">:</span> <span class="s1">&#39;OrMerge&#39;</span><span class="p">,</span>
            <span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="s1">&#39;Union of index plans&#39;</span><span class="p">,</span>
            <span class="s1">&#39;child_plans&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">explain</span><span class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span> <span class="ow">or</span> <span class="p">[])]</span>
        <span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AndMerge</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
    <span class="n">and_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span>
    <span class="n">residual_filters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">and_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">residual_filters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span> <span class="o">=</span> <span class="n">and_queries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residual_filters</span> <span class="o">=</span> <span class="n">residual_filters</span> <span class="ow">or</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intersect sub-queries by stable references to minimize materialization.</span>
<span class="sd">        Each sub-plan is asked for get_references(); if unavailable, we fallback to hashing</span>
<span class="sd">        materialized records. After computing the intersection, we materialize only from the</span>
<span class="sd">        smallest contributing sub-plan and yield records whose reference is in the intersection.</span>
<span class="sd">        Residual filters (non-indexable terms) are applied at the end to the few remaining records.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># Collect reference sets and keep a plan to materialize from</span>
        <span class="n">ref_sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">QueryPlan</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">:</span>
            <span class="n">refs</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s1">&#39;get_references&#39;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">refs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s1">&#39;get_references&#39;</span><span class="p">)())</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">refs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">refs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">refs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Fallback: derive refs from materialized records (less efficient)</span>
                <span class="n">hset</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="s1">&#39;atom_pointer&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                                <span class="n">hset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">atom_pointer</span><span class="o">.</span><span class="n">hash</span><span class="p">())</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">hset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">hash</span><span class="p">())</span>
                                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                    <span class="n">hset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">rec</span><span class="p">))</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">continue</span>
                    <span class="n">refs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">hset</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">refs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span>
            <span class="n">ref_sets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">refs</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>

        <span class="c1"># Early exit if any is empty</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">rs</span> <span class="ow">in</span> <span class="n">ref_sets</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Sort by ascending size for efficient intersection</span>
        <span class="n">ref_sets</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">base_refs</span><span class="p">,</span> <span class="n">base_plan</span> <span class="o">=</span> <span class="n">ref_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">base_refs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rs</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ref_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">intersection</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">intersection</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="c1"># Materialize minimally: iterate the smallest plan and filter by intersection</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_ref_of</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="s1">&#39;atom_pointer&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">atom_pointer</span><span class="o">.</span><span class="n">hash</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">hash</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_matches_residual</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_filters</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_filters</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">rec</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">base_plan</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_ref_of</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="ow">in</span> <span class="n">intersection</span> <span class="ow">and</span> <span class="n">_matches_residual</span><span class="p">(</span><span class="n">rec</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">rec</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;plan_type&#39;</span><span class="p">:</span> <span class="s1">&#39;AndMerge&#39;</span><span class="p">,</span>
            <span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="s1">&#39;Intersecting sorted index plans&#39;</span><span class="p">,</span>
            <span class="s1">&#39;child_plans&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">explain</span><span class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span> <span class="ow">or</span> <span class="p">[])],</span>
            <span class="s1">&#39;residual_filters&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residual_filters</span> <span class="ow">or</span> <span class="p">[])]</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">AndMerge</span><span class="p">(</span>
            <span class="n">and_queries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the count of the intersection of sub-queries.</span>
<span class="sd">        It optimizes by iterating the smaller result set and checking for</span>
<span class="sd">        existence in the larger one, without materializing full objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Optimize sub-queries first</span>
        <span class="n">optimized_queries</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">]</span>

        <span class="c1"># Get iterators of IDs, not full objects</span>
        <span class="n">id_iterators</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">keys_iterator</span><span class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">optimized_queries</span><span class="p">]</span>

        <span class="c1"># Sort by potential size (if a count() method is available)</span>
        <span class="n">id_iterators</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">it</span><span class="p">:</span> <span class="n">it</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>

        <span class="c1"># Use the smallest set as the base for iteration</span>
        <span class="n">base_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">id_iterators</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">base_ids</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Intersect with the other sets</span>
        <span class="k">for</span> <span class="n">other_iterator</span> <span class="ow">in</span> <span class="n">id_iterators</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">base_ids</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">other_iterator</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base_ids</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">base_ids</span><span class="p">)</span>


<div class="viewcode-block" id="IndexedRangeSearchPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IndexedRangeSearchPlan</span><span class="p">(</span><span class="n">IndexedQueryPlan</span><span class="p">):</span>
    <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">include_lower</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">include_upper</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">lo</span><span class="p">:</span> <span class="nb">object</span>
    <span class="n">hi</span><span class="p">:</span> <span class="nb">object</span>

<div class="viewcode-block" id="IndexedRangeSearchPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">include_lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">include_upper</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                 <span class="n">indexes</span><span class="p">:</span> <span class="n">Dictionary</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span> <span class="o">=</span> <span class="n">field_to_scan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">=</span> <span class="n">lo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hi</span> <span class="o">=</span> <span class="n">hi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span> <span class="o">=</span> <span class="n">include_lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">=</span> <span class="n">include_upper</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Prefer using the index if available; otherwise, fallback to based_on</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Fallback should not normally happen if optimizer set this, but guard anyway</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">rec</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">IndexedRangeSearchPlan</span><span class="p">(</span>
            <span class="n">field_to_scan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span>
            <span class="n">lo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="p">,</span>
            <span class="n">hi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hi</span><span class="p">,</span>
            <span class="n">include_lower</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span><span class="p">,</span>
            <span class="n">include_upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.count">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.count">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.get_cardinality_estimate">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.get_cardinality_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cardinality_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Heuristic estimate for range scans. Use 25% of based_on count when available; otherwise a small constant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;based_on&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">est</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total</span> <span class="o">*</span> <span class="mf">0.25</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">est</span> <span class="k">if</span> <span class="n">est</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.get_cost_estimate">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.get_cost_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cost_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Range scans are more expensive than point lookups. Cost grows with estimated cardinality.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">10.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cardinality_estimate</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.1</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.get_references">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.get_references">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_references</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">frozenset</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a frozenset of references for all records with field value in [lo, hi]</span>
<span class="sd">        according to inclusivity flags, without materializing full objects.</span>
<span class="sd">        Performs a lower-bound binary search on the index (AVL-backed List) and then</span>
<span class="sd">        scans sequentially until the upper bound is exceeded, collecting AtomPointer hashes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">refs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">)):</span>
                <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span>
            <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">idx_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span>

            <span class="kn">from</span><span class="w"> </span><span class="nn">.dictionaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">DictionaryItem</span> <span class="k">as</span> <span class="n">_DI</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">_ok</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_DI</span><span class="o">.</span><span class="n">_order_key</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_ref_of</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="s1">&#39;atom_pointer&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">atom_pointer</span><span class="o">.</span><span class="n">hash</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">hash</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

            <span class="n">count</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">count</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">lo_ok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">center</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">iok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iok</span> <span class="o">&gt;=</span> <span class="n">lo_ok</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">center</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Adjust exclusivity for lower bound</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">:</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span> <span class="ow">and</span> <span class="n">it</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">hi_ok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hi</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">:</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">key_ok</span> <span class="o">=</span> <span class="n">_ok</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key_ok</span> <span class="o">&gt;</span> <span class="n">hi_ok</span> <span class="ow">or</span> <span class="p">(</span><span class="n">key_ok</span> <span class="o">==</span> <span class="n">hi_ok</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="ow">and</span> <span class="n">it</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">key_ok</span> <span class="o">&lt;</span> <span class="n">lo_ok</span> <span class="ow">or</span> <span class="p">(</span><span class="n">key_ok</span> <span class="o">==</span> <span class="n">lo_ok</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span> <span class="ow">and</span> <span class="n">it</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">it</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">value_set</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                    <span class="n">refs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_ref_of</span><span class="p">(</span><span class="n">rec</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">refs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.explain">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.explain">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1"># Build inclusive/exclusive range string</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="s1">&#39;[&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span> <span class="k">else</span> <span class="s1">&#39;(&#39;</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="s1">&#39;]&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="k">else</span> <span class="s1">&#39;)&#39;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lb</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">hi</span><span class="si">}{</span><span class="n">ub</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;plan_type&#39;</span><span class="p">:</span> <span class="s1">&#39;IndexedRangeSearchPlan&#39;</span><span class="p">,</span>
            <span class="s1">&#39;index_used&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span>
            <span class="s1">&#39;lookup_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Range Scan&#39;</span><span class="p">,</span>
            <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="n">rng</span><span class="p">,</span>
            <span class="s1">&#39;estimated_cardinality&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cardinality_estimate</span><span class="p">(),</span>
            <span class="s1">&#39;estimated_cost&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cost_estimate</span><span class="p">(),</span>
        <span class="p">}</span></div>
</div>



<div class="viewcode-block" id="FromPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FromPlan</span><span class="p">(</span><span class="n">IndexedQueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span>

<div class="viewcode-block" id="FromPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">RepeatedKeysDictionary</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alias</span> <span class="ow">and</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">indexes</span>
                <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">indexes</span> <span class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="n">alias</span></div>


<div class="viewcode-block" id="FromPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">DBObject</span><span class="p">(</span>
                <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">field_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">result</span></div>


<div class="viewcode-block" id="FromPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FromPlan</span><span class="p">(</span>
            <span class="n">alias</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="JoinPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.JoinPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">JoinPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Join two query plans with simple heuristic-based join semantics.</span>

<span class="sd">    Supported join_type values in tests:</span>

<span class="sd">    - &#39;inner&#39;: only matching pairs</span>
<span class="sd">    - &#39;left&#39;: all from left, matching from right when available</span>
<span class="sd">    - &#39;right&#39;: all from right, matching from left when available</span>
<span class="sd">    - &#39;external&#39;: cartesian product of both sides plus both sides individually</span>
<span class="sd">    - &#39;external_left&#39;: left-only plus cartesian product</span>
<span class="sd">    - &#39;external_right&#39;: right-only plus cartesian product</span>
<span class="sd">    - &#39;outer&#39;: only side-only elements (no combining)</span>

<span class="sd">    Matching heuristic for inner/left/right::</span>

<span class="sd">      If left has field &quot;{right_alias}_id&quot; and right has field &quot;id&quot;:</span>
<span class="sd">        left.{right_alias}_id == right.id</span>
<span class="sd">      Else if left has field &quot;id&quot; and right has field &quot;{left_alias}_id&quot;:</span>
<span class="sd">        left.id == right.{left_alias}_id</span>
<span class="sd">      Otherwise, no match.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="JoinPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.JoinPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">join_query</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">,</span>
                 <span class="n">join_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;inner&#39;</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">join_query</span> <span class="o">=</span> <span class="n">join_query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">join_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">join_type</span> <span class="ow">or</span> <span class="s1">&#39;inner&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_detect_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">,</span> <span class="n">sample_record</span><span class="p">:</span> <span class="n">DBObject</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Prefer alias from FromPlan</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">FromPlan</span> <span class="k">as</span> <span class="n">_FromPlan</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plan</span><span class="p">,</span> <span class="n">_FromPlan</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">plan</span><span class="o">.</span><span class="n">alias</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># Otherwise, infer from record attributes if it has a single public attribute</span>
        <span class="k">if</span> <span class="n">sample_record</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pub</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sample_record</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pub</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_side_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rec</span><span class="p">:</span> <span class="n">DBObject</span><span class="p">,</span> <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alias</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rec</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lrec</span><span class="p">:</span> <span class="n">DBObject</span><span class="p">,</span> <span class="n">rrec</span><span class="p">:</span> <span class="n">DBObject</span><span class="p">,</span> <span class="n">la</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ra</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">left_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_side_object</span><span class="p">(</span><span class="n">lrec</span><span class="p">,</span> <span class="n">la</span><span class="p">)</span>
        <span class="n">right_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_side_object</span><span class="p">(</span><span class="n">rrec</span><span class="p">,</span> <span class="n">ra</span><span class="p">)</span>
        <span class="c1"># Try left.{ra}_id == right.id</span>
        <span class="n">key1</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ra</span><span class="si">}</span><span class="s2">_id&quot;</span> <span class="k">if</span> <span class="n">ra</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key1</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">left_obj</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">right_obj</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">left_obj</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">right_obj</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># Try left.id == right.{la}_id</span>
        <span class="n">key2</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">la</span><span class="si">}</span><span class="s2">_id&quot;</span> <span class="k">if</span> <span class="n">la</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">left_obj</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key2</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">right_obj</span><span class="p">,</span> <span class="n">key2</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">left_obj</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">right_obj</span><span class="p">,</span> <span class="n">key2</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_copy_public_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">DBObject</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">DBObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DBObject</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="n">DBObject</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">DBObject</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DBObject</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">DBObject</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_public_attrs</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_public_attrs</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="JoinPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.JoinPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">right_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">join_query</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_query</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="n">la</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_alias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">,</span> <span class="n">left_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">left_list</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_alias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">join_query</span><span class="p">,</span> <span class="n">right_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">right_list</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">jt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_type</span>
        <span class="k">if</span> <span class="n">jt</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span><span class="p">:</span>
            <span class="c1"># Only side-only, no combined pairs</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">left_list</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">right_list</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">jt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;external&#39;</span><span class="p">):</span>
            <span class="n">include_left_only</span> <span class="o">=</span> <span class="n">jt</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;external&#39;</span><span class="p">,</span> <span class="s1">&#39;external_left&#39;</span><span class="p">)</span>
            <span class="n">include_right_only</span> <span class="o">=</span> <span class="n">jt</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;external&#39;</span><span class="p">,</span> <span class="s1">&#39;external_right&#39;</span><span class="p">)</span>
            <span class="c1"># Cartesian combinations of both sides</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">left_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">right_list</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">include_left_only</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">left_list</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">include_right_only</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">right_list</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># inner/left/right using match</span>
        <span class="k">if</span> <span class="n">jt</span> <span class="o">==</span> <span class="s1">&#39;inner&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">left_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">right_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="n">ra</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">jt</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">left_list</span><span class="p">:</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">right_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="n">ra</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                        <span class="n">matched</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">jt</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">right_list</span><span class="p">:</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">left_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="n">ra</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                        <span class="n">matched</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Fallback: treat as inner</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">left_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">right_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="n">ra</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span></div>


<div class="viewcode-block" id="JoinPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.JoinPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">JoinPlan</span><span class="p">(</span>
            <span class="n">join_query</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">join_query</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_query</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">join_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">join_type</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="RecursivePlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.RecursivePlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RecursivePlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Executes a recursive traversal starting from the records produced by `based_on`.</span>
<span class="sd">    It supports &#39;up&#39; (single reference attribute) and &#39;down&#39; (iterable attribute) directions</span>
<span class="sd">    and DFS or BFS strategies. Returns results as a List collection for efficient slicing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="RecursivePlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.RecursivePlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">,</span>
                 <span class="n">relation_attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;up&#39;</span><span class="p">,</span>
                 <span class="n">max_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;dfs&#39;</span><span class="p">,</span>
                 <span class="n">include_start_node</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbstractTransaction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relation_attr</span> <span class="o">=</span> <span class="n">relation_attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction</span> <span class="ow">or</span> <span class="s1">&#39;up&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_depth</span><span class="p">)</span> <span class="k">if</span> <span class="n">max_depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="p">(</span><span class="n">strategy</span> <span class="ow">or</span> <span class="s1">&#39;dfs&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_start_node</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">include_start_node</span><span class="p">)</span></div>


<div class="viewcode-block" id="RecursivePlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.RecursivePlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DBCollections</span><span class="p">:</span>
        <span class="c1"># Build a materialized List of results</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.lists</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> <span class="k">as</span> <span class="n">_List</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">canonical_hash</span> <span class="k">as</span> <span class="n">_canonical_hash</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_List</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>

        <span class="c1"># Gather start nodes by iterating the base plan directly (avoid assuming as_iterable)</span>
        <span class="n">start_nodes</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
                    <span class="n">start_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Fallback: try to coerce to list</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">base_coll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
                    <span class="n">start_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">base_coll</span><span class="p">,</span> <span class="s1">&#39;as_iterable&#39;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">base_coll</span><span class="p">)())</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">start_nodes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Visited set by canonical identity to avoid cycles; do NOT pre-seed with start nodes</span>
        <span class="n">visited</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Worklist stores (node, depth)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;bfs&#39;</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
            <span class="n">work</span> <span class="o">=</span> <span class="n">deque</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">start_nodes</span><span class="p">)</span>
            <span class="n">pop_fn</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">popleft</span>
            <span class="n">push_fn</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">append</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">work</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">start_nodes</span><span class="p">]</span>
            <span class="n">pop_fn</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">pop</span>
            <span class="n">push_fn</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">append</span>

        <span class="c1"># Optionally include starting nodes (and mark as visited if we include them)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_start_node</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">start_nodes</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">_canonical_hash</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">h</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">append_last</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># Traverse</span>
        <span class="k">while</span> <span class="n">work</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">pop_fn</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># empty or error</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Compute next nodes</span>
            <span class="n">next_nodes</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">related</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">relation_attr</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Missing attribute → no expansion</span>
                <span class="n">related</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">related</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">next_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">related</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># down</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">related</span><span class="p">)</span> <span class="k">if</span> <span class="n">related</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">iter</span><span class="p">(())</span>
                    <span class="n">next_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">next_nodes</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">_canonical_hash</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># If we cannot hash, still emit and continue traversal (best-effort)</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">append_last</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span>
                    <span class="n">push_fn</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">append_last</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span>
                <span class="n">push_fn</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="RecursivePlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.RecursivePlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">:</span>
        <span class="c1"># Optimize the base plan; if changed, return a new RecursivePlan with optimized base</span>
        <span class="n">optimized_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">optimized_base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">optimized_base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RecursivePlan</span><span class="p">(</span>
                <span class="n">based_on</span><span class="o">=</span><span class="n">optimized_base</span><span class="p">,</span>
                <span class="n">relation_attr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">relation_attr</span><span class="p">,</span>
                <span class="n">direction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span>
                <span class="n">max_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
                <span class="n">strategy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span>
                <span class="n">include_start_node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_start_node</span><span class="p">,</span>
                <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="RecursivePlan.explain">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.RecursivePlan.explain">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">explain</span><span class="p">()</span>
        <span class="n">node</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;plan_type&#39;</span><span class="p">:</span> <span class="s1">&#39;RecursivePlan&#39;</span><span class="p">,</span>
            <span class="s1">&#39;traversal_strategy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
            <span class="s1">&#39;relation_attribute&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">relation_attr</span><span class="p">,</span>
            <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span>
            <span class="s1">&#39;max_depth&#39;</span><span class="p">:</span> <span class="s1">&#39;unlimited&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="k">return</span> <span class="n">node</span></div>
</div>



<div class="viewcode-block" id="WherePlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WherePlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Query plan for filtering records based on an expression.</span>

<span class="sd">    This plan evaluates each record from the underlying `based_on` query plan</span>
<span class="sd">    against a filtering expression (`filter`). Records that satisfy the expression</span>
<span class="sd">    are passed downstream.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - filter (Expression): An expression determining which records to retain.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">filter</span><span class="p">:</span> <span class="n">Expression</span>

<div class="viewcode-block" id="WherePlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">filter_spec</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="nb">filter</span><span class="p">:</span> <span class="n">Expression</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_spec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">filter_spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">filter</span></div>


<div class="viewcode-block" id="WherePlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DBCollections</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the filtering logic over the input records and return a DBCollections.</span>
<span class="sd">        This implementation performs a linear scan over the base records applying the filter,</span>
<span class="sd">        and materializes the result into a List to enable slicing/pagination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.lists</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> <span class="k">as</span> <span class="n">_List</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_List</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
        <span class="c1"># Prefer direct Python list if based_on is a ListPlan (common in tests)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">ListPlan</span> <span class="k">as</span> <span class="n">_ListPlan</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">,</span> <span class="n">_ListPlan</span><span class="p">):</span>
                <span class="n">iterable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">base_list</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_coll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="n">_List</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
                <span class="n">iterable</span> <span class="o">=</span> <span class="n">base_coll</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">base_coll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="n">_List</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="n">base_coll</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">rec</span><span class="p">):</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">append_last</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Ignore records that error during matching</span>
                <span class="k">continue</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="WherePlan.explain">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.explain">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1"># Fallback explanation when WherePlan is not optimized into an index-backed plan</span>
        <span class="n">node</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;plan_type&#39;</span><span class="p">:</span> <span class="s1">&#39;WherePlan&#39;</span><span class="p">,</span>
            <span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="s1">&#39;Linear Scan (Full Table Scan)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reason&#39;</span><span class="p">:</span> <span class="s1">&#39;No suitable index found for the filter expression.&#39;</span><span class="p">,</span>
            <span class="s1">&#39;filter&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;filter&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;based_on&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;source_plan&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">explain</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">node</span></div>


<div class="viewcode-block" id="WherePlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cooperative optimization: delegate term planning to QueryableIndex.</span>
<span class="sd">        - If the base is not an IndexedQueryPlan, return self (linear scan fallback).</span>
<span class="sd">        - If the filter is a Term or an AndExpression of Terms, ask each field&#39;s index</span>
<span class="sd">          (if it implements QueryableIndex) to build a specialized plan for the term.</span>
<span class="sd">        - Combine all index-backed plans with AndMerge, and keep non-indexable terms</span>
<span class="sd">          as residual_filters to be applied after intersection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Ensure we have an index-aware base plan</span>
        <span class="n">base_plan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_plan</span><span class="p">,</span> <span class="n">IndexedQueryPlan</span><span class="p">):</span>
            <span class="c1"># No indexes available → keep the plan as-is over optimized base</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="n">base_plan</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># 2) Normalize/validate the filter shape we handle now (Term or AndExpression)</span>
        <span class="n">flt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span>
        <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flt</span><span class="p">,</span> <span class="n">Term</span><span class="p">):</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">flt</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flt</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">flt</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flt</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
            <span class="c1"># We&#39;ll handle OR below using index-backed plans if all terms are indexable</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">flt</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not handled in this phase; return self (linear WherePlan over base)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="n">base_plan</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># 3) For each term, consult the corresponding index if it is QueryableIndex</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.dictionaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dictionary</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">Dictionary</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base_plan</span><span class="p">,</span> <span class="s1">&#39;indexes&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="n">base_plan</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">QueryContext</span><span class="p">,</span> <span class="n">QueryableIndex</span>  <span class="c1"># self-module safe import</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">QueryContext</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>

        <span class="n">index_plans</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">residual_filters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">built_plans</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Term</span><span class="p">):</span>
                <span class="n">residual_filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">target_attribute</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">has_idx</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">has_idx</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">has_idx</span><span class="p">:</span>
                <span class="n">residual_filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">QueryableIndex</span><span class="p">):</span>
                <span class="n">residual_filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">plan</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">build_query_plan</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">plan</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">built_plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plan</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index_plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">residual_filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="c1"># 4) If no index-backed plans, decide fallback based on filter type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">index_plans</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="n">base_plan</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># 5) If the original filter was a single Term and we have a single plan and no residuals → return it directly</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flt</span><span class="p">,</span> <span class="n">Term</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_plans</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">residual_filters</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">index_plans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># 6) If it was an OR, only succeed when all terms produced plans</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flt</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
            <span class="c1"># Success only if we built a plan for every term and none is None</span>
            <span class="k">if</span> <span class="n">built_plans</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">built_plans</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">built_plans</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">OrMerge</span><span class="p">(</span><span class="n">or_queries</span><span class="o">=</span><span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">],</span> <span class="n">built_plans</span><span class="p">),</span> <span class="n">based_on</span><span class="o">=</span><span class="n">base_plan</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="n">base_plan</span>
                <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># 7) AND-path: order by estimated cardinality (more selective first)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">index_plans</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">get_cardinality_estimate</span><span class="p">()))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># 8) If exactly one index plan and no residuals, return the plan directly</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_plans</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">residual_filters</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">index_plans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># 9) Build AndMerge with residual filters; base is preserved only for explain chaining</span>
        <span class="k">return</span> <span class="n">AndMerge</span><span class="p">(</span>
            <span class="n">and_queries</span><span class="o">=</span><span class="n">index_plans</span><span class="p">,</span>
            <span class="n">residual_filters</span><span class="o">=</span><span class="n">residual_filters</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="n">base_plan</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_reorder_and_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">and_expression</span><span class="p">:</span> <span class="s1">&#39;AndExpression&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;AndExpression&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts terms within an AndExpression based on a cost heuristic.</span>

<span class="sd">        The goal is to place less expensive and more selective terms at the</span>
<span class="sd">        beginning of the terms list. This allows the execution engine to</span>
<span class="sd">        reject non-matching records as early as possible.</span>

<span class="sd">        Args:</span>
<span class="sd">            and_expression: The AndExpression instance to reorder.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new AndExpression with the terms sorted according to the cost model.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_term_cost</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculates a cost for a filter term. A lower cost is better.</span>
<span class="sd">            This heuristic can be expanded to include index availability,</span>
<span class="sd">            cardinality estimates, etc.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Simple heuristic: equality checks are generally cheaper and more</span>
            <span class="c1"># selective than other operations.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Term</span><span class="p">)</span> <span class="ow">and</span> <span class="n">term</span><span class="o">.</span><span class="n">operation</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;==&#39;</span><span class="p">,</span> <span class="s1">&#39;eq&#39;</span><span class="p">]:</span>
                <span class="c1"># A check on an indexed field would ideally have a cost of 0.</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">10</span>  <span class="c1"># Represents a higher cost for other operations.</span>

        <span class="c1"># Sort the terms, placing the lowest-cost terms first.</span>
        <span class="n">sorted_terms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">and_expression</span><span class="o">.</span><span class="n">terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">get_term_cost</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">terms</span><span class="o">=</span><span class="n">sorted_terms</span><span class="p">)</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">AgreggatorFunction</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for aggregator functions.</span>

<span class="sd">    Aggregator functions perform operations (e.g., sum, average) over fields</span>
<span class="sd">    or records grouped under a common criteria. Each subclass implements</span>
<span class="sd">    its own logic for computing aggregate results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the aggregation over a list of values.</span>

<span class="sd">        :param values: A list of values to aggregate.</span>
<span class="sd">        :type values: list</span>
<span class="sd">        :return: The result of the aggregation.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SumAgreggator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum aggregator function for computing the sum of a list of numeric values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the total sum of the given numeric values.</span>

<span class="sd">        :param values: A list of numeric values.</span>
<span class="sd">        :type values: list[float|int]</span>
<span class="sd">        :return: The sum of all values in the list.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">total_sum</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">total_sum</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AvgAggregator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CountAggregator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MinAgreggator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">minimun</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">minimun</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">minimun</span><span class="p">:</span>
                <span class="n">minimun</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">minimun</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MaxAgreggator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An aggregator that finds the maximum value in a list of values.</span>

<span class="sd">    It initializes the maximum value to None and then iterates through the list,</span>
<span class="sd">    updating the maximum value whenever a larger value is found.</span>
<span class="sd">    It returns the overall maximum value. If the list is empty, it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the maximum value from a list of values.</span>

<span class="sd">        Args:</span>
<span class="sd">            values: The list of values to compute the maximum from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The maximum value in the list, or None if the list is empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">max_value</span><span class="p">:</span>
                <span class="n">max_value</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">max_value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AgreggatorSpec</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agreggator</span><span class="p">:</span> <span class="n">AgreggatorFunction</span><span class="p">,</span> <span class="n">source_field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_field</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agreggator</span> <span class="o">=</span> <span class="n">agreggator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_field</span> <span class="o">=</span> <span class="n">source_field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_field</span> <span class="o">=</span> <span class="n">target_field</span>


<div class="viewcode-block" id="GroupByPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.GroupByPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GroupByPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<div class="viewcode-block" id="GroupByPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.GroupByPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">group_fields</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="n">agreggated_fields</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">AgreggatorSpec</span><span class="p">],</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_fields</span> <span class="o">=</span> <span class="n">group_fields</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agreggated_fields</span> <span class="o">=</span> <span class="n">agreggated_fields</span> <span class="ow">or</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="GroupByPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.GroupByPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">groups</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">DBObject</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="p">[]):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_fields</span><span class="p">)</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">records</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">DBObject</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
            <span class="c1"># Set group fields</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_fields</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># Compute aggregations</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">agreggated_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Extract values; for sums/avgs, treat missing as 0; for min/max skip None</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">source_field</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">agreggator</span><span class="p">,</span> <span class="p">(</span><span class="n">SumAgreggator</span><span class="p">,</span> <span class="n">AvgAggregator</span><span class="p">))</span> <span class="k">else</span> <span class="p">(</span><span class="n">v</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span><span class="p">))</span>
                <span class="c1"># For avg/min/max, better to ignore None: build cleaned list when aggregator is not Count</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">agreggator</span><span class="p">,</span> <span class="n">AvgAggregator</span><span class="p">):</span>
                    <span class="n">clean</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">agreggator</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">clean</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">agreggator</span><span class="p">,</span> <span class="p">(</span><span class="n">MinAgreggator</span><span class="p">,</span> <span class="n">MaxAgreggator</span><span class="p">)):</span>
                    <span class="n">clean</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">source_field</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">agreggator</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">clean</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">agreggator</span><span class="p">,</span> <span class="n">CountAggregator</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">agreggator</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">agreggator</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">target_field</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">out</span></div>


<div class="viewcode-block" id="GroupByPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.GroupByPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">GroupByPlan</span><span class="p">(</span>
            <span class="n">group_fields</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_fields</span><span class="p">),</span>
            <span class="n">agreggated_fields</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agreggated_fields</span><span class="p">),</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="UnnestPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.UnnestPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UnnestPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plan that flattens a collection from each input record.</span>
<span class="sd">    - source_path: dotted path string or callable(record) -&gt; iterable</span>
<span class="sd">    - element_alias: if provided, the element is attached to the original record under this key; otherwise the element replaces the record.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="UnnestPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.UnnestPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_path</span><span class="p">,</span> <span class="n">element_alias</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span> <span class="o">=</span> <span class="n">source_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span> <span class="o">=</span> <span class="n">element_alias</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">record</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">cur</span>

<div class="viewcode-block" id="UnnestPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.UnnestPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="c1"># determine the collection</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">collection</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_path</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">)</span>
            <span class="c1"># check iterability (avoid strings/bytes)</span>
            <span class="k">if</span> <span class="n">collection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem</span>
                        <span class="k">yield</span> <span class="n">out</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># assume DBObject-like</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">record</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="p">{</span><span class="o">**</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="s1">&#39;items&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}),</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span><span class="p">:</span> <span class="n">elem</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">elem</span></div>


<div class="viewcode-block" id="UnnestPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.UnnestPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="CollectionFieldPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CollectionFieldPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CollectionFieldPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each left record, executes a subplan built from it and attaches the collected results as a list under field_name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CollectionFieldPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CollectionFieldPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">subplan_builder</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_name</span> <span class="o">=</span> <span class="n">field_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subplan_builder</span> <span class="o">=</span> <span class="n">subplan_builder</span></div>


<div class="viewcode-block" id="CollectionFieldPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CollectionFieldPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">left</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="n">subplan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subplan_builder</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subplan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subplan</span> <span class="o">=</span> <span class="n">subplan</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
                <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">subplan</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span>
                <span class="k">yield</span> <span class="n">out</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">left</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;items&#39;</span><span class="p">):</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">left</span><span class="p">))</span>
                    <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span>
                    <span class="k">yield</span> <span class="n">out</span></div>


<div class="viewcode-block" id="CollectionFieldPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CollectionFieldPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="SelectPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SelectPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A query plan that selects and transforms fields from records produced by another query plan.</span>

<span class="sd">    This plan allows for both direct field mapping (renaming fields) and dynamic field</span>
<span class="sd">    generation through callable functions. It&#39;s useful for projecting and transforming</span>
<span class="sd">    data in a query pipeline.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SelectPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="s1">&#39;ObjectTransaction&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a SelectPlan with field mappings and a base query plan.</span>

<span class="sd">        Args:</span>
<span class="sd">            fields: A dictionary mapping output field names to either:</span>
<span class="sd">                   - Source field names (strings) for direct mapping</span>
<span class="sd">                   - Callable functions that take a record and return a value</span>
<span class="sd">            based_on: The query plan that produces the records to transform</span>
<span class="sd">            transaction: The transaction context</span>
<span class="sd">            atom_pointer: Pointer to the atom in storage</span>
<span class="sd">            **kwargs: Additional arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">fields</span></div>


<div class="viewcode-block" id="SelectPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the plan, transforming records from the base plan according to field mappings.</span>

<span class="sd">        For each record from the base plan, this method creates a new record with fields</span>
<span class="sd">        mapped according to the field specification provided at initialization.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Transformed records with the specified field mappings applied.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Any exception that might be raised by callable field mappings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">output_field</span><span class="p">,</span> <span class="n">source_spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">source_spec</span><span class="p">):</span>
                    <span class="c1"># Dynamic field generation through a callable</span>
                    <span class="c1"># Let any exceptions propagate up to the caller</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">output_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_spec</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Direct field mapping</span>
                    <span class="c1"># Only include the field if it exists in the source record</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">source_spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">output_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">yield</span> <span class="n">result</span></div>


<div class="viewcode-block" id="SelectPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize this plan and its dependencies.</span>

<span class="sd">        This method delegates optimization to the underlying plan and then</span>
<span class="sd">        creates a new SelectPlan with the optimized base.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An optimized version of this plan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">optimized_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">optimized_base</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">SelectPlan</span><span class="p">(</span>
            <span class="n">fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="n">optimized_base</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="CountPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CountPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A query plan that counts the results from a sub-plan.</span>
<span class="sd">    This plan is optimized to use index counts whenever possible,</span>
<span class="sd">    avoiding full data iteration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CountPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="s1">&#39;ObjectTransaction&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the CountPlan.</span>

<span class="sd">        Args:</span>
<span class="sd">            based_on: The underlying plan whose results will be counted.</span>
<span class="sd">            transaction: The active transaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="s1">&#39;count&#39;</span></div>


<div class="viewcode-block" id="CountPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the count. If no optimization is possible,</span>
<span class="sd">        it iterates through the sub-plan&#39;s results and counts them.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list containing a single dictionary with the count, e.g., [{&#39;count&#39;: 123}].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">count</span><span class="p">}]</span></div>


<div class="viewcode-block" id="CountPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimizes the counting process.</span>

<span class="sd">        If the underlying plan can provide a count efficiently (e.g., it&#39;s an</span>
<span class="sd">        indexed search), this method will delegate the counting to it.</span>
<span class="sd">        Otherwise, it returns itself to perform a standard iteration count.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A plan that can provide the count, potentially a new optimized plan</span>
<span class="sd">            or itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optimized_based_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

        <span class="c1"># Duck-typing: Check if the optimized underlying plan has a fast `count` method.</span>
        <span class="c1"># Only delegate if the method is overridden (not the default QueryPlan.count).</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">optimized_based_on</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Special-case: don&#39;t delegate for plain ListPlan (no fast path expected)</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">ListPlan</span> <span class="k">as</span> <span class="n">_ListPlan</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimized_based_on</span><span class="p">,</span> <span class="n">_ListPlan</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Use default path for ListPlan&#39;</span><span class="p">)</span>
                <span class="c1"># Otherwise, delegate if a count method is present</span>
                <span class="k">return</span> <span class="n">CountResultPlan</span><span class="p">(</span><span class="n">count_value</span><span class="o">=</span><span class="n">optimized_based_on</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Fall through to default behavior</span>
                <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="n">optimized_based_on</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">ArrayAgg</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aggregator that collects values into a list (array aggregation).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>


<div class="viewcode-block" id="CountResultPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CountResultPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A terminal plan that simply holds and returns a pre-calculated count.</span>
<span class="sd">    This is the result of an optimized CountPlan.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CountResultPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_value</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="s1">&#39;ObjectTransaction&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_value</span> <span class="o">=</span> <span class="n">count_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="s1">&#39;count&#39;</span></div>


<div class="viewcode-block" id="CountResultPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_value</span><span class="p">}]</span></div>


<div class="viewcode-block" id="CountResultPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">SelectManyPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements a correlated subquery for each element of a source plan,</span>
<span class="sd">    equivalent to CROSS JOIN LATERAL or LINQ&#39;s SelectMany.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">,</span>
                 <span class="n">collection_selector</span><span class="p">,</span>
                 <span class="n">result_selector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbstractTransaction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection_selector</span> <span class="o">=</span> <span class="n">collection_selector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_selector</span> <span class="o">=</span> <span class="n">result_selector</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Execute left side</span>
        <span class="n">left_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">left_record</span> <span class="ow">in</span> <span class="n">left_iter</span><span class="p">:</span>
            <span class="c1"># Build right side for each left</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">right_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection_selector</span><span class="p">(</span><span class="n">left_record</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">right_collection</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># If it&#39;s a Queryable, execute its plan; avoid top-level import to reduce cycles</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">.linq</span><span class="w"> </span><span class="kn">import</span> <span class="n">Queryable</span> <span class="k">as</span> <span class="n">_Queryable</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_collection</span><span class="p">,</span> <span class="n">_Queryable</span><span class="p">):</span>
                    <span class="n">right_plan</span> <span class="o">=</span> <span class="n">right_collection</span><span class="o">.</span><span class="n">_execute</span><span class="p">()</span>
                    <span class="n">right_iterable</span> <span class="o">=</span> <span class="n">right_plan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">right_iterable</span> <span class="o">=</span> <span class="n">right_collection</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">right_iterable</span> <span class="o">=</span> <span class="n">right_collection</span>

            <span class="c1"># Iterate and yield</span>
            <span class="k">for</span> <span class="n">right_record</span> <span class="ow">in</span> <span class="n">right_iterable</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_selector</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_selector</span><span class="p">(</span><span class="n">left_record</span><span class="p">,</span> <span class="n">right_record</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="c1"># Skip records that fail the selector</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">right_record</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">:</span>
        <span class="n">optimized_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">optimized_base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">optimized_base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SelectManyPlan</span><span class="p">(</span>
                <span class="n">based_on</span><span class="o">=</span><span class="n">optimized_base</span><span class="p">,</span>
                <span class="n">collection_selector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collection_selector</span><span class="p">,</span>
                <span class="n">result_selector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">result_selector</span><span class="p">,</span>
                <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">explain</span><span class="p">()</span>
        <span class="n">node</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;plan_type&#39;</span><span class="p">:</span> <span class="s1">&#39;SelectManyPlan (LATERAL JOIN)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;For each record from the source plan, a correlated sub-query is dynamically generated and executed.&#39;</span>
        <span class="p">})</span>
        <span class="k">return</span> <span class="n">node</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, ProtoBase Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>