<!DOCTYPE html>
<html class="writer-html5" data-content_root="../../" lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>proto_db.queries &mdash; ProtoBase 0.1.0 documentation</title>
    <link href="../../_static/pygments.css?v=80d5e7a1" rel="stylesheet" type="text/css"/>
    <link href="../../_static/css/theme.css?v=e59714d7" rel="stylesheet" type="text/css"/>


    <script src="../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../_static/documentation_options.js?v=01f34227"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link href="../../genindex.html" rel="index" title="Index"/>
    <link href="../../search.html" rel="search" title="Search"/>
</head>

<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
    <nav class="wy-nav-side" data-toggle="wy-nav-shift">
        <div class="wy-side-scroll">
            <div class="wy-side-nav-search">


                <a class="icon icon-home" href="../../index.html">
                    ProtoBase
                </a>
                <div role="search">
                    <form action="../../search.html" class="wy-form" id="rtd-search-form" method="get">
                        <input aria-label="Search docs" name="q" placeholder="Search docs" type="text"/>
                        <input name="check_keywords" type="hidden" value="yes"/>
                        <input name="area" type="hidden" value="default"/>
                    </form>
                </div>
            </div>
            <div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
                <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../architecture.html">Architecture</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../advanced_usage.html">Advanced
                        Usage</a></li>
                    <li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a>
                    </li>
                </ul>

            </div>
        </div>
    </nav>

    <section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
        <nav aria-label="Mobile navigation menu" class="wy-nav-top">
            <i class="fa fa-bars" data-toggle="wy-nav-top"></i>
            <a href="../../index.html">ProtoBase</a>
        </nav>

        <div class="wy-nav-content">
            <div class="rst-content">
                <div aria-label="Page navigation" role="navigation">
                    <ul class="wy-breadcrumbs">
                        <li><a aria-label="Home" class="icon icon-home" href="../../index.html"></a></li>
                        <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
                        <li class="breadcrumb-item active">proto_db.queries</li>
                        <li class="wy-breadcrumbs-aside">
                        </li>
                    </ul>
                    <hr/>
                </div>
                <div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
                    <div itemprop="articleBody">

                        <h1>Source code for proto_db.queries</h1>
                        <div class="highlight"><pre>
<span></span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">selectors</span> <span class="kn">import</span> <span class="n">SelectSelector</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">cast</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span
                                class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span
                                class="n">DBCollections</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">ProtoUnexpectedException</span><span
                                class="p">,</span> <span class="n">ProtoValidationException</span><span
                                class="p">,</span> <span class="n">ProtoCorruptionException</span>
<span class="kn">from</span> <span class="nn">.common</span> <span class="kn">import</span> <span
                                class="n">Atom</span><span class="p">,</span> <span class="n">QueryPlan</span><span
                                class="p">,</span> <span class="n">AtomPointer</span><span class="p">,</span> <span
                                class="n">DBObject</span>
<span class="kn">from</span> <span class="nn">.db_access</span> <span class="kn">import</span> <span class="n">ObjectTransaction</span>
<span class="kn">from</span> <span class="nn">.lists</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">.dictionaries</span> <span class="kn">import</span> <span class="n">RepeatedKeysDictionary</span><span
                                class="p">,</span> <span class="n">Dictionary</span><span class="p">,</span> <span
                                class="n">DictionaryItem</span>
<span class="kn">from</span> <span class="nn">.sets</span> <span class="kn">import</span> <span class="n">Set</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>
<span class="kn">from</span> <span class="nn">.hybrid_executor</span> <span class="kn">import</span> <span class="n">HybridExecutor</span>


<span class="c1"># Executor for async operations</span>
<span class="n">max_workers</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span
                                class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span
                                class="ow">or</span> <span class="mi">1</span><span class="p">)</span> <span
                                class="o">*</span> <span class="mi">5</span>
<span class="n">executor_pool</span> <span class="o">=</span> <span class="n">HybridExecutor</span><span
                                class="p">(</span><span class="n">base_num_workers</span><span class="o">=</span><span
                                class="n">max_workers</span> <span class="o">//</span> <span class="mi">5</span><span
                                class="p">,</span> <span class="n">sync_multiplier</span><span class="o">=</span><span
                                class="mi">5</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Expression</span><span class="p">(</span><span class="n">ABC</span><span
                                class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for all expression types used to filter or match records.</span>

<span class="sd">    Expressions represent logical conditions that can be applied to records, such as</span>
<span class="sd">    &quot;and&quot;, &quot;or&quot;, &quot;not&quot;, or specific comparisons (terms). Subclasses must implement</span>
<span class="sd">    the `match` method to define their behavior for evaluating a record.</span>

<span class="sd">    The `Expression` structure is highly flexible and supports composition of multiple</span>
<span class="sd">    logical operators for complex filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span
                                class="n">expression</span><span class="p">:</span> <span class="nb">list</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span
                                class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile a nested list of expressions into an `Expression` object.</span>

<span class="sd">        The method parses a structured list, where operators (`!`, `&amp;`, and `|`)</span>
<span class="sd">        and terms are used to build a tree of expressions (e.g., AndExpression,</span>
<span class="sd">        OrExpression, etc.). These compiled objects can then be used to evaluate</span>
<span class="sd">        whether a record satisfies the given conditions.</span>

<span class="sd">        :param expression: A nested list representing logical operations and terms.</span>
<span class="sd">        :type expression: list</span>
<span class="sd">        :return: A fully compiled `Expression` instance.</span>
<span class="sd">        :rtype: Expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span
                                class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span
                                class="nb">tuple</span><span class="p">[</span><span class="n">Expression</span><span
                                class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span
                                class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span
                                class="p">:</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">following_expression</span><span class="p">,</span> <span
                                class="n">local_index</span> <span class="o">=</span> <span
                                class="n">collect_expression</span><span class="p">(</span><span
                                class="n">local_index</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">NotExpression</span><span class="p">(</span><span
                                class="n">following_expression</span><span class="p">),</span> <span class="n">local_index</span>
            <span class="k">elif</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span
                                class="p">]</span> <span class="o">==</span> <span
                                class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">first_operand</span><span class="p">,</span> <span class="n">local_index</span> <span
                                class="o">=</span> <span class="n">collect_expression</span><span
                                class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="n">second_operand</span><span class="p">,</span> <span class="n">local_index</span> <span
                                class="o">=</span> <span class="n">collect_expression</span><span
                                class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">AndExpression</span><span class="p">([</span><span
                                class="n">first_operand</span><span class="p">,</span> <span
                                class="n">second_operand</span><span class="p">]),</span> <span
                                class="n">local_index</span>
            <span class="k">elif</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span
                                class="p">]</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span
                                class="p">:</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">first_operand</span><span class="p">,</span> <span class="n">local_index</span> <span
                                class="o">=</span> <span class="n">collect_expression</span><span
                                class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="n">second_operand</span><span class="p">,</span> <span class="n">local_index</span> <span
                                class="o">=</span> <span class="n">collect_expression</span><span
                                class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">OrExpression</span><span class="p">([</span><span
                                class="n">first_operand</span><span class="p">,</span> <span
                                class="n">second_operand</span><span class="p">]),</span> <span
                                class="n">local_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># It should be a plain term</span>
                <span class="n">term_def</span> <span class="o">=</span> <span class="n">expression</span><span
                                class="p">[</span><span class="n">local_index</span><span class="p">]</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span
                                class="n">term_def</span><span class="p">)</span> <span class="o">&lt;</span> <span
                                class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                        <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Invalid term definition: </span><span
                                class="si">{</span><span class="n">term_def</span><span class="si">}</span><span
                                class="s1">. It should contain at least two operands!&#39;</span>
                    <span class="p">)</span>
                <span class="n">operand</span> <span class="o">=</span> <span class="n">Operator</span><span
                                class="o">.</span><span class="n">get_operator</span><span class="p">(</span><span
                                class="n">term_def</span><span class="p">[</span><span class="mi">1</span><span
                                class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span
                                class="n">term_def</span><span class="p">)</span> <span class="o">!=</span> <span
                                class="n">operand</span><span class="o">.</span><span
                                class="n">parameter_count</span> <span class="o">+</span> <span class="mi">1</span><span
                                class="p">:</span>
                    <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                        <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Operand </span><span
                                class="si">{</span><span class="n">operand</span><span class="si">}</span><span
                                class="s1"> expect at list </span><span class="si">{</span><span
                                class="n">operand</span><span class="o">.</span><span
                                class="n">parameter_count</span><span class="si">}</span><span class="s1"> parameters!&#39;</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">term_def</span><span
                                class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">operand</span><span
                                class="p">,</span> <span class="n">term_def</span><span class="p">[</span><span
                                class="mi">2</span><span class="p">]),</span> <span class="n">local_index</span>

        <span class="n">default_and_expression</span> <span class="o">=</span> <span class="nb">list</span><span
                                class="p">()</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span
                                class="nb">len</span><span class="p">(</span><span class="n">expression</span><span
                                class="p">):</span>
            <span class="n">new_expression</span><span class="p">,</span> <span class="n">index</span> <span
                                class="o">=</span> <span class="n">collect_expression</span><span
                                class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">default_and_expression</span><span class="o">.</span><span class="n">append</span><span
                                class="p">(</span><span class="n">new_expression</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">default_and_expression</span><span
                                class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">default_and_expression</span><span
                                class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default_and_expression</span><span class="p">[</span><span
                                class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">filter_by_alias</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span
                                class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span
                                class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">Term</span><span class="p">):</span>
            <span class="n">atribute_alias</span> <span class="o">=</span> <span class="bp">self</span><span
                                class="o">.</span><span class="n">target_attribute</span><span class="o">.</span><span
                                class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span
                                class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span
                                class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span
                                class="p">]</span>
            <span class="k">if</span> <span class="n">atribute_alias</span> <span class="ow">in</span> <span class="n">alias</span><span
                                class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TrueTerm</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">AndExpression</span><span
                                class="p">):</span>
            <span class="n">new_operands</span><span class="p">:</span> <span class="nb">list</span><span
                                class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span
                                class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">terms</span><span
                                class="p">:</span>
                <span class="n">new_operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span
                                class="n">operand</span><span class="o">.</span><span
                                class="n">filter_by_alias</span><span class="p">(</span><span
                                class="n">alias</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">new_operands</span><span
                                class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">OrExpression</span><span
                                class="p">):</span>
            <span class="k">return</span> <span class="n">TrueTerm</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">NotExpression</span><span
                                class="p">):</span>
            <span class="k">return</span> <span class="n">NotExpression</span><span class="p">(</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">negated_expression</span><span class="o">.</span><span
                                class="n">filter_by_alias</span><span class="p">(</span><span
                                class="n">alias</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;It&#39;s not possible to filter </span><span
                                class="si">{</span><span class="bp">self</span><span class="si">}</span><span
                                class="s2"> expression by alias!&quot;</span>
            <span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">record</span><span class="p">)</span> <span
                                class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matches a given record against specific criteria defined by the implementation.</span>

<span class="sd">        This method is abstract and must be implemented by a subclass to provide the</span>
<span class="sd">        logic for determining whether the provided record satisfies the required</span>
<span class="sd">        conditions. The exact nature of the matching depends on the subclass</span>
<span class="sd">        implementation.</span>

<span class="sd">        :param record: The record to be evaluated.</span>
<span class="sd">        :type record: Any</span>
<span class="sd">        :return: A boolean value indicating whether the record matches the criteria.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">AndExpression</span><span class="p">(</span><span
                                class="n">Expression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logical &#39;AND&#39; expression for combining multiple conditions.</span>

<span class="sd">    Evaluates as True only if all terms in the `terms` list evaluate to True for a record.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - terms (list[Expression]): Sub-expressions that must all evaluate as True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span
                                class="n">Expression</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span
                                class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span
                                class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span
                                class="n">terms</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate if the given record matches all sub-term conditions.</span>

<span class="sd">        :param record: The input record to evaluate.</span>
<span class="sd">        :type record: Any</span>
<span class="sd">        :return: True if all terms match the record, False otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">terms</span><span
                                class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span
                                class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">record</span><span
                                class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">OrExpression</span><span class="p">(</span><span
                                class="n">Expression</span><span class="p">):</span>
    <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span
                                class="n">Expression</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span
                                class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span
                                class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span
                                class="n">terms</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">terms</span><span
                                class="p">:</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span
                                class="n">match</span><span class="p">(</span><span class="n">record</span><span
                                class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">NotExpression</span><span class="p">(</span><span
                                class="n">Expression</span><span class="p">):</span>
    <span class="n">negated_expression</span><span class="p">:</span> <span class="n">Expression</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">negated_expression</span><span
                                class="p">:</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negated_expression</span> <span
                                class="o">=</span> <span class="n">negated_expression</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span
                                class="o">.</span><span class="n">negated_expression</span><span class="o">.</span><span
                                class="n">match</span><span class="p">(</span><span class="n">record</span><span
                                class="p">)</span>


<span class="k">class</span> <span class="nc">Operator</span><span class="p">(</span><span class="n">ABC</span><span
                                class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for comparison operators.</span>

<span class="sd">    Operators define how a source value should be compared to another value</span>
<span class="sd">    to produce a boolean result. Subclasses implement different kinds of</span>
<span class="sd">    comparisons, such as equality, inequality, or inclusion.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - parameter_count (int): The number of parameters this operator expects for comparison.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="n">string</span><span
                                class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method to get an operator instance based on a string representation.</span>

<span class="sd">        This allows dynamic resolution of operator behavior (e.g., &#39;==&#39;, &#39;!=&#39;, &#39;contains&#39;)</span>
<span class="sd">        at runtime. If the operator string is not recognized, an exception is raised.</span>

<span class="sd">        :param string: The string representation of the operator (e.g., &#39;==&#39;, &#39;in&#39;).</span>
<span class="sd">        :type string: str</span>
<span class="sd">        :return: An instance of a subclass of `Operator`.</span>
<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">string</span> <span class="o">==</span> <span
                                class="s1">&#39;==&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Equal</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;!=&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">NotEqual</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&gt;&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">Greater</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&gt;=&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">GreaterOrEqual</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">Lower</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&lt;=&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">LowerOrEqual</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;contains&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">Contains</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">In</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?T&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">IsTrue</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?!T&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">NotTrue</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?N&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">IsNone</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?!N&#39;</span><span
                                class="p">:</span>
            <span class="k">return</span> <span class="n">NotNone</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Unknown operator: </span><span
                                class="si">{</span><span class="n">string</span><span class="si">}</span><span
                                class="s1">!&#39;</span>
            <span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span
                                class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is an abstract method that should be implemented in derived</span>
<span class="sd">        classes. It is designed to match the provided source against a specific</span>
<span class="sd">        value and return a result based on this matching process. The exact</span>
<span class="sd">        implementation and criteria of the match are dependent on the</span>
<span class="sd">        implementation in the subclass.</span>

<span class="sd">        :param source: The primary input against which the matching process</span>
<span class="sd">            will be performed. The exact nature of &#39;source&#39; depends on the</span>
<span class="sd">            implementation in the subclass.</span>
<span class="sd">        :param value: Optional value against which &#39;source&#39; will be matched.</span>
<span class="sd">            If not provided, the behavior may vary based on the subclass</span>
<span class="sd">            implementation.</span>
<span class="sd">        :return: The result of the matching process. The exact type and</span>
<span class="sd">            content of the returned value depend on the specific implementation</span>
<span class="sd">            in the subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Equal</span><span class="p">(</span><span class="n">Operator</span><span
                                class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">2</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">==</span> <span
                                class="n">value</span>


<span class="k">class</span> <span class="nc">NotEqual</span><span class="p">(</span><span
                                class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">2</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">!=</span> <span
                                class="n">value</span>


<span class="k">class</span> <span class="nc">Greater</span><span class="p">(</span><span class="n">Operator</span><span
                                class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">2</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&gt;</span> <span
                                class="n">value</span>


<span class="k">class</span> <span class="nc">GreaterOrEqual</span><span class="p">(</span><span
                                class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">2</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&gt;=</span> <span
                                class="n">value</span>


<span class="k">class</span> <span class="nc">Lower</span><span class="p">(</span><span class="n">Operator</span><span
                                class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">2</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&lt;</span> <span
                                class="n">value</span>


<span class="k">class</span> <span class="nc">LowerOrEqual</span><span class="p">(</span><span class="n">Operator</span><span
                                class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">2</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&lt;=</span> <span
                                class="n">value</span>


<span class="k">class</span> <span class="nc">Contains</span><span class="p">(</span><span
                                class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">2</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span
                                class="n">source</span>


<span class="k">class</span> <span class="nc">In</span><span class="p">(</span><span class="n">Operator</span><span
                                class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">2</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="ow">in</span> <span
                                class="n">value</span>


<span class="k">class</span> <span class="nc">IsTrue</span><span class="p">(</span><span class="n">Operator</span><span
                                class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">1</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span
                                class="n">source</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NotTrue</span><span class="p">(</span><span class="n">Operator</span><span
                                class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">1</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span
                                class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IsNone</span><span class="p">(</span><span class="n">Operator</span><span
                                class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">1</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="ow">is</span> <span
                                class="kc">None</span>


<span class="k">class</span> <span class="nc">NotNone</span><span class="p">(</span><span class="n">Operator</span><span
                                class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span
                                class="mi">1</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">source</span><span class="p">,</span> <span
                                class="n">value</span><span class="o">=</span><span class="kc">None</span><span
                                class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="ow">is</span> <span
                                class="ow">not</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">Term</span><span class="p">(</span><span class="n">Expression</span><span
                                class="p">):</span>
    <span class="n">target_attribute</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">operation</span><span class="p">:</span> <span class="n">Operator</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">object</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">target_attribute</span><span class="p">:</span> <span
                                class="nb">str</span><span class="p">,</span> <span class="n">operation</span><span
                                class="p">:</span> <span class="n">Operator</span><span class="p">,</span> <span
                                class="n">value</span><span class="p">:</span> <span class="nb">object</span><span
                                class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_attribute</span> <span
                                class="o">=</span> <span class="n">target_attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operation</span> <span
                                class="o">=</span> <span class="n">operation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span
                                class="n">value</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">operation</span><span class="o">.</span><span class="n">match</span><span
                                class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span
                                class="bp">self</span><span class="o">.</span><span
                                class="n">target_attribute</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">TrueTerm</span><span class="p">(</span><span
                                class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">FalseTerm</span><span class="p">(</span><span
                                class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="ListPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan">[docs]</a>
<span class="k">class</span> <span class="nc">ListPlan</span><span class="p">(</span><span
        class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a QueryPlan from a python list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_list</span><span class="p">:</span> <span class="nb">list</span>

<div class="viewcode-block" id="ListPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span>
                 <span class="n">base_list</span><span class="p">:</span> <span class="nb">list</span><span
        class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span
        class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span
        class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
        class="fm">__init__</span><span class="p">(</span><span class="n">transaction</span><span
        class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span
        class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span
        class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_list</span> <span
        class="o">=</span> <span class="n">base_list</span></div>


<div class="viewcode-block" id="ListPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan.execute">[docs]</a>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
        class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span
        class="bp">self</span><span class="o">.</span><span class="n">base_list</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span></div>


<div class="viewcode-block" id="ListPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan.optimize">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
        class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span
        class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<span class="k">class</span> <span class="nc">IndexedQueryPlan</span><span class="p">(</span><span
                                class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IndexedQueryPlan is a specialized version of QueryPlan.</span>

<span class="sd">    It provides functionality for creating and managing indexed query plans</span>
<span class="sd">    that optimize query execution based on indexed data sources. This class</span>
<span class="sd">    extends the base functionality of QueryPlan to incorporate the use of</span>
<span class="sd">    indices in query operations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="n">Dictionary</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">:</span> <span class="n">Dictionary</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
                                class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span
                                class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span
                                class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span
                                class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span
                                class="n">transaction</span><span class="p">,</span> <span class="o">**</span><span
                                class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span
                                class="o">=</span> <span class="n">indexes</span> <span class="k">if</span> <span
                                class="n">indexes</span> <span class="k">else</span> <span
                                class="n">Dictionary</span><span class="p">(</span><span
                                class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">transaction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span
                                class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span
                                class="o">.</span><span class="n">execute</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
                                class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span
                                class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">based_on</span><span class="o">.</span><span
                                class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span
                                class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_index</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span>
                  <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span
                                class="n">IndexedQueryPlan</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an index to the database for optimizing query performance on specified columns. This method</span>
<span class="sd">        creates a new index with the given name on the columns specified in the list. Indexing can</span>
<span class="sd">        significantly improve the efficiency of certain queries, particularly for large datasets.</span>

<span class="sd">        :param field_name: field the index will be created on</span>
<span class="sd">        :return: An indexed query plan that contains details of the created index and its application</span>
<span class="sd">                 to the underlying query structure.</span>
<span class="sd">        :rtype: IndexedQueryPlan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">indexes</span><span class="o">.</span><span class="n">has</span><span
                                class="p">(</span><span class="n">field_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Reindex the current content on the added field</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">RepeatedKeysDictionary</span><span
                                class="p">(</span><span class="n">transaction</span><span class="o">=</span><span
                                class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span
                                class="p">)</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span
                                class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span
                                class="n">has</span><span class="p">(</span><span class="n">field_name</span><span
                                class="p">):</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="n">new_index</span><span
                                class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">record</span><span
                                class="p">[</span><span class="n">field_name</span><span class="p">],</span> <span
                                class="n">record</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">set_at</span><span
                                class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span
                                class="n">new_index</span><span class="p">),</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_indexes_on_remove</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">removed_record</span><span class="p">:</span> <span
                                class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span
                                class="n">IndexedQueryPlan</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update indexes when specific data is removed from a collection or database.</span>

<span class="sd">        This function updates the internal indexes to maintain consistency</span>
<span class="sd">        after the specified data is removed. It ensures that subsequent</span>
<span class="sd">        queries reflect the correct indexed structure.</span>

<span class="sd">        :param removed_record: The data item that was removed, for which the</span>
<span class="sd">            indexes need to be updated.</span>
<span class="sd">        :return: An updated query plan reflecting the state of indexes</span>
<span class="sd">            after the removal.</span>
<span class="sd">        :rtype: IndexedQueryPlan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">indexes</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span
                                class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span
                                class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">as_iterable</span><span
                                class="p">():</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">RepeatedKeysDictionary</span><span class="p">,</span> <span
                                class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">removed_record</span><span class="p">[</span><span class="n">field_name</span><span
                                class="p">]:</span>
                <span class="n">new_indexes</span><span class="o">.</span><span class="n">set_at</span><span
                                class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span
                                class="n">index</span><span class="o">.</span><span
                                class="n">remove_record_at</span><span class="p">(</span><span
                                class="n">removed_record</span><span class="p">[</span><span class="n">field_name</span><span
                                class="p">],</span> <span class="n">removed_record</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">new_indexes</span><span
                                class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_indexes_on_add</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">added_record</span><span class="p">:</span> <span
                                class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span
                                class="n">IndexedQueryPlan</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the indexed query plan when an item is added to the dataset.</span>

<span class="sd">        The method ensures that the internal indexes are recalibrated after</span>
<span class="sd">        removing any existing data that would conflict with the new item&#39;s</span>
<span class="sd">        location or plan alignment in the indexed structure. It recalculates</span>
<span class="sd">        and returns the updated query plan that reflects the modifications.</span>

<span class="sd">        :param added_record: the added data.</span>
<span class="sd">        :return: The updated IndexedQueryPlan object after modification to</span>
<span class="sd">            reflect changes caused by the addition operation.</span>
<span class="sd">        :rtype: IndexedQueryPlan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">indexes</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span
                                class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span
                                class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">as_iterable</span><span
                                class="p">():</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">RepeatedKeysDictionary</span><span class="p">,</span> <span
                                class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">added_record</span><span class="p">[</span><span class="n">field_name</span><span
                                class="p">]:</span>
                <span class="n">new_indexes</span><span class="o">.</span><span class="n">set_at</span><span
                                class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span
                                class="n">index</span><span class="o">.</span><span class="n">set_at</span><span
                                class="p">(</span><span class="n">added_record</span><span class="p">[</span><span
                                class="n">field_name</span><span class="p">],</span> <span class="n">added_record</span><span
                                class="p">))</span>

        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">new_indexes</span><span
                                class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">position_at</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span
                                class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span
                                class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="p">[</span><span class="n">field_name</span><span class="p">])</span>

            <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">index</span><span
                                class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">count</span> <span
                                class="o">-</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span
                                class="n">right</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span
                                class="n">left</span> <span class="o">+</span> <span class="n">right</span><span
                                class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

                <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span
                                class="n">DictionaryItem</span><span class="p">,</span> <span
                                class="n">index</span><span class="o">.</span><span class="n">content</span><span
                                class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">center</span><span
                                class="p">))</span>
                <span class="k">if</span> <span class="n">item</span> <span class="ow">and</span> <span
                                class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span
                                class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span
                                class="p">:</span>
                    <span class="k">return</span> <span class="n">center</span>

                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span
                                class="o">.</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span
                                class="n">value</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span
                                class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">center</span> <span
                                class="o">+</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;No index on field </span><span
                                class="si">{</span><span class="n">field_name</span><span class="si">}</span><span
                                class="s1">!&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">yield_from_index</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span
                                class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span
                                class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span
                                class="nb">list</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="p">[</span><span class="n">field_name</span><span class="p">]</span><span
                                class="o">.</span><span class="n">count</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span
                                class="p">))</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span
                                class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span
                                class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span> <span class="nf">get_greater_than</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span
                                class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span
                                class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">position_at</span><span class="p">(</span><span
                                class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">)</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span
                                class="n">DictionaryItem</span><span class="p">,</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="p">[</span><span class="n">field_name</span><span class="p">]</span><span
                                class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span
                                class="p">))</span>
        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span
                                class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_from_index</span><span
                                class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span
                                class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_greater_or_equal_than</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span
                                class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span
                                class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">position_at</span><span class="p">(</span><span
                                class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_from_index</span><span
                                class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span
                                class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_equal_than</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span
                                class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span
                                class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="p">[</span><span class="n">field_name</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span
                                class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span
                                class="n">index</span><span class="o">.</span><span class="n">get_at</span><span
                                class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span
                                class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span
                                class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;No index on field </span><span
                                class="si">{</span><span class="n">field_name</span><span class="si">}</span><span
                                class="s1">!&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">yield_up_to_index</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span
                                class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index_up_to</span><span
                                class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span
                                class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="p">[</span><span class="n">field_name</span><span class="p">]</span><span
                                class="o">.</span><span class="n">count</span> <span class="ow">and</span> <span
                                class="n">index</span> <span class="o">&lt;</span> <span
                                class="n">index_up_to</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span
                                class="p">))</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span
                                class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span
                                class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span
                                class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span> <span class="nf">get_lower_than</span><span class="p">(</span><span
                                class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span
                                class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span
                                class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">position_at</span><span class="p">(</span><span
                                class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">)</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span
                                class="n">DictionaryItem</span><span class="p">,</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span
                                class="p">[</span><span class="n">field_name</span><span class="p">]</span><span
                                class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span
                                class="p">))</span>
        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span
                                class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_up_to_index</span><span
                                class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span
                                class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_lower_or_equal_than</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span
                                class="nb">str</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span
                                class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">position_at</span><span class="p">(</span><span
                                class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span
                                class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_up_to_index</span><span
                                class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span
                                class="n">index</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IndexedSearchPlan</span><span class="p">(</span><span class="n">IndexedQueryPlan</span><span
                                class="p">):</span>
    <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span><span
                                class="p">,</span>
            <span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">:</span> <span class="n">Dictionary</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
                                class="fm">__init__</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span
                                class="p">,</span>
            <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span
                                class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span
                                class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">field_to_scan</span><span
                                class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;The field to scan should be specified!&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">operator</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;The operator should be specified!&#39;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span> <span
                                class="o">=</span> <span class="n">field_to_scan</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span
                                class="n">operator</span><span class="p">,</span> <span class="p">(</span>
                <span class="n">Lower</span><span class="p">,</span> <span class="n">LowerOrEqual</span><span class="p">,</span> <span
                                class="n">Equal</span><span class="p">,</span> <span
                                class="n">GreaterOrEqual</span><span class="p">,</span> <span
                                class="n">Greater</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;The operator is not valid (</span><span
                                class="si">{</span><span class="n">operator</span><span class="si">}</span><span
                                class="s1">)!&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span
                                class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span
                                class="n">value</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span
                                class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">operator</span><span class="p">,</span> <span
                                class="n">Equal</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_equal_than</span><span
                                class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span
                                class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span
                                class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span
                                class="bp">self</span><span class="o">.</span><span class="n">operator</span><span
                                class="p">,</span> <span class="n">Greater</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_greater_than</span><span
                                class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span
                                class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span
                                class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span
                                class="bp">self</span><span class="o">.</span><span class="n">operator</span><span
                                class="p">,</span> <span class="n">GreaterOrEqual</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_greater_or_equal_than</span><span
                                class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span
                                class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span
                                class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span
                                class="bp">self</span><span class="o">.</span><span class="n">operator</span><span
                                class="p">,</span> <span class="n">Lower</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lower_than</span><span
                                class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span
                                class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span
                                class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span
                                class="bp">self</span><span class="o">.</span><span class="n">operator</span><span
                                class="p">,</span> <span class="n">LowerOrEqual</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lower_or_equal_than</span><span
                                class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span
                                class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span
                                class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
                                class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span
                                class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">IndexedSearchPlan</span><span class="p">(</span>
            <span class="n">field_to_scan</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">operator</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">based_on</span><span class="o">.</span><span
                                class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span
                                class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span
                                class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a fast count of results by leveraging the underlying index count.</span>
<span class="sd">        This avoids iterating over the actual data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of items that match the search criteria.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This assumes the underlying plan is an IndexedQueryPlan, which it should be.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">operator</span> <span class="ow">in</span> <span class="p">[</span><span
                                class="s1">&#39;==&#39;</span><span class="p">,</span> <span
                                class="s1">&#39;eq&#39;</span><span class="p">]:</span>
            <span class="c1"># The `get_equal_than` method returns a list-like object from the index</span>
            <span class="c1"># that already knows its own count.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">based_on</span><span class="o">.</span><span
                                class="n">get_equal_than</span><span class="p">(</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">value</span><span
                                class="p">)</span><span class="o">.</span><span class="n">count</span>

        <span class="c1"># For other operators like &#39;&gt;&#39;, &#39;&lt;&#39;, etc., we might still need to iterate,</span>
        <span class="c1"># but only on the index, which is still faster than a full table scan.</span>
        <span class="c1"># A simple implementation would be:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span
                                class="nb">list</span><span class="p">(</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">execute</span><span class="p">()))</span>


<span class="k">class</span> <span class="nc">AndMerge</span><span class="p">(</span><span
                                class="n">QueryPlan</span><span class="p">):</span>
    <span class="n">and_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span
                                class="n">QueryPlan</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span>
                 <span class="n">and_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span
                                class="n">QueryPlan</span><span class="p">]</span> <span class="o">=</span> <span
                                class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span
                                class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span
                                class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
                                class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span
                                class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span
                                class="n">transaction</span><span class="o">=</span><span
                                class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span
                                class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span
                                class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span> <span class="o">=</span> <span
                                class="n">and_queries</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span
                                class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">accumulators</span> <span class="o">=</span> <span class="nb">list</span><span
                                class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span
                                class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span
                                class="nb">len</span><span class="p">(</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">and_queries</span><span class="p">)):</span>
            <span class="n">accumulators</span><span class="o">.</span><span class="n">append</span><span
                                class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">record</span> <span
                                class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span
                                class="p">[</span><span class="n">i</span><span class="p">]</span><span
                                class="o">.</span><span class="n">execute</span><span class="p">()]))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">and_queries</span><span class="p">)</span> <span
                                class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">accumulators</span><span
                                class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="n">record</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">accumulators</span><span
                                class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span
                                class="p">(</span><span class="mi">1</span><span class="p">,</span> <span
                                class="nb">len</span><span class="p">(</span><span class="n">accumulators</span><span
                                class="p">)):</span>
                    <span class="k">if</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">accumulators</span><span
                                class="p">[</span><span class="n">index</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">add</span><span
                                class="p">(</span><span class="n">record</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span
                                class="n">result</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
                                class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span
                                class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">AndMerge</span><span class="p">(</span>
            <span class="n">and_queries</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">and_queries</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">based_on</span><span class="o">.</span><span
                                class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span
                                class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span
                                class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the count of the intersection of sub-queries.</span>
<span class="sd">        It optimizes by iterating the smaller result set and checking for</span>
<span class="sd">        existence in the larger one, without materializing full objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span
                                class="n">and_queries</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Optimize sub-queries first</span>
        <span class="n">optimized_queries</span> <span class="o">=</span> <span class="p">[</span><span
                                class="n">q</span><span class="o">.</span><span class="n">optimize</span><span
                                class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span
                                class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span
                                class="o">.</span><span class="n">and_queries</span><span class="p">]</span>

        <span class="c1"># Get iterators of IDs, not full objects</span>
        <span class="n">id_iterators</span> <span class="o">=</span> <span class="p">[</span><span
                                class="n">q</span><span class="o">.</span><span class="n">keys_iterator</span><span
                                class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span
                                class="ow">in</span> <span class="n">optimized_queries</span><span class="p">]</span>

        <span class="c1"># Sort by potential size (if a count() method is available)</span>
        <span class="n">id_iterators</span><span class="o">.</span><span class="n">sort</span><span
                                class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span
                                class="n">it</span><span class="p">:</span> <span class="n">it</span><span
                                class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="k">if</span> <span
                                class="nb">hasattr</span><span class="p">(</span><span class="n">it</span><span
                                class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span> <span
                                class="k">else</span> <span class="nb">float</span><span class="p">(</span><span
                                class="s1">&#39;inf&#39;</span><span class="p">))</span>

        <span class="c1"># Use the smallest set as the base for iteration</span>
        <span class="n">base_ids</span> <span class="o">=</span> <span class="nb">set</span><span
                                class="p">(</span><span class="n">id_iterators</span><span class="p">[</span><span
                                class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">base_ids</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Intersect with the other sets</span>
        <span class="k">for</span> <span class="n">other_iterator</span> <span class="ow">in</span> <span class="n">id_iterators</span><span
                                class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">base_ids</span><span class="o">.</span><span class="n">intersection_update</span><span
                                class="p">(</span><span class="n">other_iterator</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base_ids</span><span
                                class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">base_ids</span><span
                                class="p">)</span>


<span class="k">class</span> <span class="nc">OrMerge</span><span class="p">(</span><span
                                class="n">QueryPlan</span><span class="p">):</span>
    <span class="n">or_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span
                                class="n">QueryPlan</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span>
                 <span class="n">or_queries</span><span class="p">:</span> <span class="nb">list</span><span
                                class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span
                                class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span
                                class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span
                                class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
                                class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span
                                class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span
                                class="n">transaction</span><span class="o">=</span><span
                                class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span
                                class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span
                                class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span> <span
                                class="o">=</span> <span class="n">or_queries</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span
                                class="p">:</span>
        <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span
                                class="bp">self</span><span class="o">.</span><span class="n">or_queries</span><span
                                class="p">:</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span
                                class="n">query</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
                                class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span
                                class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">OrMerge</span><span class="p">(</span>
            <span class="n">or_queries</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">or_queries</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">based_on</span><span class="o">.</span><span
                                class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span
                                class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
                                class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span
                                class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the count of the union of sub-queries.</span>
<span class="sd">        It uses a set to efficiently combine IDs and get the final count</span>
<span class="sd">        of unique results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Optimize sub-queries and get their ID iterators</span>
        <span class="n">optimized_queries</span> <span class="o">=</span> <span class="p">[</span><span
                                class="n">q</span><span class="o">.</span><span class="n">optimize</span><span
                                class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span
                                class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span
                                class="o">.</span><span class="n">or_queries</span><span class="p">]</span>
        <span class="n">id_iterators</span> <span class="o">=</span> <span class="p">[</span><span
                                class="n">q</span><span class="o">.</span><span class="n">keys_iterator</span><span
                                class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span
                                class="ow">in</span> <span class="n">optimized_queries</span><span class="p">]</span>

        <span class="c1"># Union all IDs using a set to handle duplicates automatically</span>
        <span class="n">all_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iterator</span> <span class="ow">in</span> <span class="n">id_iterators</span><span
                                class="p">:</span>
            <span class="n">all_ids</span><span class="o">.</span><span class="n">update</span><span
                                class="p">(</span><span class="n">iterator</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span
                                class="n">all_ids</span><span class="p">)</span>


<div class="viewcode-block" id="FromPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan">[docs]</a>
<span class="k">class</span> <span class="nc">FromPlan</span><span class="p">(</span><span
        class="n">IndexedQueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span>

<div class="viewcode-block" id="FromPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span>
                 <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span><span
        class="p">,</span>
                 <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span
        class="p">[</span><span class="nb">str</span><span class="p">,</span> <span
        class="n">RepeatedKeysDictionary</span><span class="p">],</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span><span
        class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span
        class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span
        class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alias</span> <span class="ow">and</span> <span
        class="n">indexes</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span
        class="n">alias</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span
        class="n">field_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span
        class="n">indexes</span>
                <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">indexes</span> <span
        class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span
        class="p">()</span>
            <span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
        class="fm">__init__</span><span class="p">(</span><span class="n">indexes</span><span class="o">=</span><span
        class="n">indexes</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span
        class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span
        class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span
        class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span
        class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span
        class="n">alias</span></div>


<div class="viewcode-block" id="FromPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan.execute">[docs]</a>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
        class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span
        class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span
        class="n">execute</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">DBObject</span><span
        class="p">(</span>
                <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
        class="o">.</span><span class="n">transaction</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">alias</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span
        class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span
        class="o">.</span><span class="n">alias</span><span class="p">,</span> <span class="n">item</span><span
        class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">value</span> <span
        class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="vm">__dict__</span><span
        class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">field_name</span><span
        class="o">.</span><span class="n">startswith</span><span class="p">(</span><span
        class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span
        class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span
        class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span
        class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="n">field_name</span><span
        class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">result</span></div>


<div class="viewcode-block" id="FromPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan.optimize">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
        class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span
        class="p">:</span>
        <span class="k">return</span> <span class="n">FromPlan</span><span class="p">(</span>
            <span class="n">alias</span><span class="o">=</span><span class="bp">self</span><span
        class="o">.</span><span class="n">alias</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span
        class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span
        class="p">(</span><span class="n">full_plan</span><span class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
        class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WherePlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan">[docs]</a>
<span class="k">class</span> <span class="nc">WherePlan</span><span class="p">(</span><span
        class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Query plan for filtering records based on an expression.</span>

<span class="sd">    This plan evaluates each record from the underlying `based_on` query plan</span>
<span class="sd">    against a filtering expression (`filter`). Records that satisfy the expression</span>
<span class="sd">    are passed downstream.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - filter (Expression): An expression determining which records to retain.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">filter</span><span class="p">:</span> <span class="n">Expression</span>

<div class="viewcode-block" id="WherePlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span>
                 <span class="n">filter_spec</span><span class="p">:</span> <span class="nb">list</span> <span
        class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="nb">filter</span><span class="p">:</span> <span class="n">Expression</span> <span
        class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span
        class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span
        class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span
        class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
        class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span
        class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span
        class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span
        class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span
        class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span
        class="n">filter_spec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span
        class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">compile</span><span
        class="p">(</span><span class="n">filter_spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span
        class="o">=</span> <span class="nb">filter</span></div>


<div class="viewcode-block" id="WherePlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.execute">[docs]</a>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
        class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the filtering logic over the input records.</span>

<span class="sd">        Each record is checked against the `filter` expression. Only records</span>
<span class="sd">        that match the filter are yielded.</span>

<span class="sd">        :return: A generator yielding filtered records.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span
        class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">filter</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span
        class="n">record</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">record</span></div>


<div class="viewcode-block" id="WherePlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.optimize">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
        class="s1">&#39;QueryPlan&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span
        class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimizes the current execution plan node.</span>

<span class="sd">        This method is a core part of the query optimizer. It applies several</span>
<span class="sd">        strategies to transform the query plan into a more efficient equivalent.</span>
<span class="sd">        The primary optimizations include:</span>
<span class="sd">        1.  Filter Reordering: For AND expressions, reorder predicates to execute</span>
<span class="sd">            the most selective and least expensive ones first.</span>
<span class="sd">        2.  Predicate Pushdown: Attempt to move the filter logic (&quot;predicate&quot;)</span>
<span class="sd">            further down the execution tree, closer to the data source. This</span>
<span class="sd">            reduces the volume of data processed in upstream operators (like Joins).</span>
<span class="sd">        3.  Index Utilization: If a predicate can be satisfied using an index,</span>
<span class="sd">            transform this plan node into an `IndexedSearchPlan`.</span>

<span class="sd">        Args:</span>
<span class="sd">            full_plan: The root of the entire query plan, providing context if needed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An optimized `QueryPlan`, which may be a different type of node</span>
<span class="sd">            (e.g., `IndexedSearchPlan`) or a reconfigured `WherePlan`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, recursively optimize the source plan upon which this filter operates.</span>
        <span class="n">optimized_based_on</span> <span class="o">=</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span
        class="p">(</span><span class="n">full_plan</span><span class="p">)</span>

        <span class="c1"># 1. FILTER REORDERING</span>
        <span class="c1"># For composite AND expressions, reorder the terms based on a cost/selectivity</span>
        <span class="c1"># heuristic. This ensures that cheaper and more selective predicates are</span>
        <span class="c1"># evaluated first, potentially short-circuiting the evaluation early.</span>
        <span class="n">current_filter</span> <span class="o">=</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">filter</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_filter</span><span
        class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
            <span class="n">current_filter</span> <span class="o">=</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">_reorder_and_expression</span><span class="p">(</span><span class="n">current_filter</span><span
        class="p">)</span>

        <span class="c1"># 2. PREDICATE PUSHDOWN</span>
        <span class="c1"># Attempt to &quot;push&quot; this where clause down to the underlying plan node.</span>
        <span class="c1"># If the underlying node has an `accept_filter` method, it means it can</span>
        <span class="c1"># integrate the filter more efficiently (e.g., a JoinPlan applying it</span>
        <span class="c1"># pre-join, or a FromPlan applying it at the storage access level).</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">optimized_based_on</span><span
        class="p">,</span> <span class="s1">&#39;accept_filter&#39;</span><span class="p">):</span>
            <span class="c1"># The underlying plan will absorb the filter and return a new, optimized plan.</span>
            <span class="c1"># This `WherePlan` node can then be eliminated from the tree.</span>
            <span class="k">return</span> <span class="n">optimized_based_on</span><span class="o">.</span><span
        class="n">accept_filter</span><span class="p">(</span><span class="n">current_filter</span><span
        class="p">)</span>

        <span class="c1"># 3. INDEX UTILIZATION (the original optimization)</span>
        <span class="c1"># Check if the filter is a simple equality term that can be served by an index</span>
        <span class="c1"># on the underlying `IndexedQueryPlan`.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_filter</span><span
        class="p">,</span> <span class="n">Term</span><span class="p">)</span> <span class="ow">and</span> <span
        class="nb">isinstance</span><span class="p">(</span><span class="n">current_filter</span><span
        class="o">.</span><span class="n">operation</span><span class="p">,</span> <span class="n">Equal</span><span
        class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimized_based_on</span><span
        class="p">,</span> <span class="n">IndexedQueryPlan</span><span class="p">):</span>
                <span class="c1"># If the target attribute is indexed, replace this `WherePlan`</span>
                <span class="c1"># with a more efficient `IndexedSearchPlan`.</span>
                <span class="k">if</span> <span class="n">current_filter</span><span class="o">.</span><span class="n">target_attribute</span> <span
        class="ow">in</span> <span class="n">optimized_based_on</span><span class="o">.</span><span
        class="n">indexes</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">IndexedSearchPlan</span><span class="p">(</span>
                        <span class="n">field_to_scan</span><span class="o">=</span><span
        class="n">current_filter</span><span class="o">.</span><span class="n">target_attribute</span><span
        class="p">,</span>
                        <span class="n">operator</span><span class="o">=</span><span
        class="n">current_filter</span><span class="o">.</span><span class="n">operation</span><span class="p">,</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">current_filter</span><span
        class="o">.</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">indexes</span><span class="o">=</span><span
        class="n">optimized_based_on</span><span class="o">.</span><span class="n">indexes</span><span
        class="p">,</span>
                        <span class="n">based_on</span><span class="o">=</span><span class="n">optimized_based_on</span><span
        class="p">,</span>
                        <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
        class="o">.</span><span class="n">transaction</span>
                    <span class="p">)</span>

        <span class="c1"># If no specific optimization could be applied, return a `WherePlan`</span>
        <span class="c1"># with the optimized base and the (potentially reordered) filter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span
        class="o">=</span> <span class="n">optimized_based_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span
        class="n">current_filter</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span> <span class="nf">_reorder_and_expression</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">and_expression</span><span class="p">:</span> <span class="s1">&#39;AndExpression&#39;</span><span
        class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;AndExpression&#39;</span><span
        class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts terms within an AndExpression based on a cost heuristic.</span>

<span class="sd">        The goal is to place less expensive and more selective terms at the</span>
<span class="sd">        beginning of the terms list. This allows the execution engine to</span>
<span class="sd">        reject non-matching records as early as possible.</span>

<span class="sd">        Args:</span>
<span class="sd">            and_expression: The AndExpression instance to reorder.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new AndExpression with the terms sorted according to the cost model.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_term_cost</span><span class="p">(</span><span
        class="n">term</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculates a cost for a filter term. A lower cost is better.</span>
<span class="sd">            This heuristic can be expanded to include index availability,</span>
<span class="sd">            cardinality estimates, etc.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Simple heuristic: equality checks are generally cheaper and more</span>
            <span class="c1"># selective than other operations.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span
        class="n">term</span><span class="p">,</span> <span class="n">Term</span><span class="p">)</span> <span
        class="ow">and</span> <span class="n">term</span><span class="o">.</span><span class="n">operation</span> <span
        class="ow">in</span> <span class="p">[</span><span class="s1">&#39;==&#39;</span><span class="p">,</span> <span
        class="s1">&#39;eq&#39;</span><span class="p">]:</span>
                <span class="c1"># A check on an indexed field would ideally have a cost of 0.</span>
                <span class="k">return</span> <span class="mi">1</span> 
            <span class="k">return</span> <span class="mi">10</span> <span class="c1"># Represents a higher cost for other operations.</span>

        <span class="c1"># Sort the terms, placing the lowest-cost terms first.</span>
        <span class="n">sorted_terms</span> <span class="o">=</span> <span class="nb">sorted</span><span
        class="p">(</span><span class="n">and_expression</span><span class="o">.</span><span class="n">terms</span><span
        class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">get_term_cost</span><span
        class="p">)</span>
        <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span
        class="n">terms</span><span class="o">=</span><span class="n">sorted_terms</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">AgreggatorFunction</span><span class="p">(</span><span
                                class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for aggregator functions.</span>

<span class="sd">    Aggregator functions perform operations (e.g., sum, average) over fields</span>
<span class="sd">    or records grouped under a common criteria. Each subclass implements</span>
<span class="sd">    its own logic for computing aggregate results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">values</span><span class="p">:</span> <span
                                class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the aggregation over a list of values.</span>

<span class="sd">        :param values: A list of values to aggregate.</span>
<span class="sd">        :type values: list</span>
<span class="sd">        :return: The result of the aggregation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">SumAgreggator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span
                                class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum aggregator function for computing the sum of a list of numeric values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">values</span><span class="p">:</span> <span
                                class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the total sum of the given numeric values.</span>

<span class="sd">        :param values: A list of numeric values.</span>
<span class="sd">        :type values: list[float|int]</span>
<span class="sd">        :return: The sum of all values in the list.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span
                                class="p">:</span>
            <span class="n">total_sum</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">total_sum</span>

<span class="k">class</span> <span class="nc">AvgAggregator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span
                                class="p">):</span>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">values</span><span class="p">:</span> <span
                                class="nb">list</span><span class="p">):</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span
                                class="p">:</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span
                                class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span> <span class="o">/</span> <span
                                class="nb">len</span><span class="p">(</span><span class="n">values</span><span
                                class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>


<span class="k">class</span> <span class="nc">CountAggregator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span
                                class="p">):</span>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">values</span><span class="p">:</span> <span
                                class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span
                                class="n">values</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MinAgreggator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span
                                class="p">):</span>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">values</span><span class="p">:</span> <span
                                class="nb">list</span><span class="p">):</span>
        <span class="n">minimun</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span
                                class="p">:</span>
            <span class="k">if</span> <span class="n">minimun</span> <span class="ow">is</span> <span
                                class="kc">None</span> <span class="ow">or</span> <span class="n">value</span> <span
                                class="o">&lt;</span> <span class="n">minimun</span><span class="p">:</span>
                <span class="n">minimun</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">minimun</span>

<span class="k">class</span> <span class="nc">MaxAggregator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span
                                class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An aggregator that finds the maximum value in a list of values.</span>

<span class="sd">    It initializes the maximum value to None and then iterates through the list,</span>
<span class="sd">    updating the maximum value whenever a larger value is found.</span>
<span class="sd">    It returns the overall maximum value. If the list is empty, it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span
                                class="p">,</span> <span class="n">values</span><span class="p">:</span> <span
                                class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the maximum value from a list of values.</span>

<span class="sd">        Args:</span>
<span class="sd">            values: The list of values to compute the maximum from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The maximum value in the list, or None if the list is empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span
                                class="p">:</span>
            <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span
                                class="kc">None</span> <span class="ow">or</span> <span class="n">value</span> <span
                                class="o">&gt;</span> <span class="n">max_value</span><span class="p">:</span>
                <span class="n">max_value</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">max_value</span>


<div class="viewcode-block" id="SelectPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan">[docs]</a>
<span class="k">class</span> <span class="nc">SelectPlan</span><span class="p">(</span><span
        class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A query plan that selects and transforms fields from records produced by another query plan.</span>

<span class="sd">    This plan allows for both direct field mapping (renaming fields) and dynamic field</span>
<span class="sd">    generation through callable functions. It&#39;s useful for projecting and transforming</span>
<span class="sd">    data in a query pipeline.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SelectPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="nb">dict</span><span
        class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span
        class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span
        class="n">transaction</span><span class="p">:</span> <span class="s1">&#39;ObjectTransaction&#39;</span> <span
        class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span
        class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span
        class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a SelectPlan with field mappings and a base query plan.</span>

<span class="sd">        Args:</span>
<span class="sd">            fields: A dictionary mapping output field names to either:</span>
<span class="sd">                   - Source field names (strings) for direct mapping</span>
<span class="sd">                   - Callable functions that take a record and return a value</span>
<span class="sd">            based_on: The query plan that produces the records to transform</span>
<span class="sd">            transaction: The transaction context</span>
<span class="sd">            atom_pointer: Pointer to the atom in storage</span>
<span class="sd">            **kwargs: Additional arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
        class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span
        class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span
        class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span
        class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span
        class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span
        class="n">fields</span></div>


<div class="viewcode-block" id="SelectPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan.execute">[docs]</a>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
        class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the plan, transforming records from the base plan according to field mappings.</span>

<span class="sd">        For each record from the base plan, this method creates a new record with fields</span>
<span class="sd">        mapped according to the field specification provided at initialization.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Transformed records with the specified field mappings applied.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Any exception that might be raised by callable field mappings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span
        class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">output_field</span><span class="p">,</span> <span class="n">source_spec</span> <span
        class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span
        class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">source_spec</span><span
        class="p">):</span>
                    <span class="c1"># Dynamic field generation through a callable</span>
                    <span class="c1"># Let any exceptions propagate up to the caller</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">output_field</span><span
        class="p">]</span> <span class="o">=</span> <span class="n">source_spec</span><span class="p">(</span><span
        class="n">record</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Direct field mapping</span>
                    <span class="c1"># Only include the field if it exists in the source record</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">record</span><span
        class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">source_spec</span><span
        class="p">)</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span
        class="kc">None</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">output_field</span><span
        class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">yield</span> <span class="n">result</span></div>


<div class="viewcode-block" id="SelectPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan.optimize">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
        class="s1">&#39;QueryPlan&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize this plan and its dependencies.</span>

<span class="sd">        This method delegates optimization to the underlying plan and then</span>
<span class="sd">        creates a new SelectPlan with the optimized base.</span>

<span class="sd">        Args:</span>
<span class="sd">            full_plan: The complete query plan for context</span>

<span class="sd">        Returns:</span>
<span class="sd">            An optimized version of this plan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span
        class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">optimized_base</span> <span class="o">=</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span
        class="p">(</span><span class="n">full_plan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">optimized_base</span> <span class="ow">is</span> <span
        class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">SelectPlan</span><span class="p">(</span>
            <span class="n">fields</span><span class="o">=</span><span class="bp">self</span><span
        class="o">.</span><span class="n">fields</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="n">optimized_base</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span
        class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>
</div>


<div class="viewcode-block" id="CountPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan">[docs]</a>
<span class="k">class</span> <span class="nc">CountPlan</span><span class="p">(</span><span
        class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A query plan that counts the results from a sub-plan.</span>
<span class="sd">    This plan is optimized to use index counts whenever possible,</span>
<span class="sd">    avoiding full data iteration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CountPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span
        class="s1">&#39;QueryPlan&#39;</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span
        class="s1">&#39;ObjectTransaction&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the CountPlan.</span>

<span class="sd">        Args:</span>
<span class="sd">            based_on: The underlying plan whose results will be counted.</span>
<span class="sd">            transaction: The active transaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
        class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span
        class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span
        class="o">=</span><span class="n">transaction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span
        class="s1">&#39;count&#39;</span></div>


<div class="viewcode-block" id="CountPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan.execute">[docs]</a>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
        class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span
        class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the count. If no optimization is possible,</span>
<span class="sd">        it iterates through the sub-plan&#39;s results and counts them.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list containing a single dictionary with the count, e.g., [{&#39;count&#39;: 123}].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span
        class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span
        class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span
        class="n">execute</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;count&#39;</span><span
        class="p">:</span> <span class="n">count</span><span class="p">}]</span></div>


<div class="viewcode-block" id="CountPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan.optimize">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
        class="s1">&#39;QueryPlan&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span
        class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimizes the counting process.</span>

<span class="sd">        If the underlying plan can provide a count efficiently (e.g., it&#39;s an</span>
<span class="sd">        indexed search), this method will delegate the counting to it.</span>
<span class="sd">        Otherwise, it returns itself to perform a standard iteration count.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A plan that can provide the count, potentially a new optimized plan</span>
<span class="sd">            or itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optimized_based_on</span> <span class="o">=</span> <span class="bp">self</span><span
        class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span
        class="p">(</span><span class="n">full_plan</span><span class="p">)</span>

        <span class="c1"># Duck-typing: Check if the optimized underlying plan has a fast `count` method.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">optimized_based_on</span><span
        class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">):</span>
            <span class="c1"># Delegate counting to the specialized method of the sub-plan.</span>
            <span class="k">return</span> <span class="n">CountResultPlan</span><span class="p">(</span><span class="n">count_value</span><span
        class="o">=</span><span class="n">optimized_based_on</span><span class="o">.</span><span
        class="n">count</span><span class="p">(),</span> <span class="n">transaction</span><span class="o">=</span><span
        class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span
        class="o">=</span> <span class="n">optimized_based_on</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="CountResultPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan">[docs]</a>
<span class="k">class</span> <span class="nc">CountResultPlan</span><span class="p">(</span><span
        class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A terminal plan that simply holds and returns a pre-calculated count.</span>
<span class="sd">    This is the result of an optimized CountPlan.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CountResultPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">count_value</span><span class="p">:</span> <span class="nb">int</span><span
        class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="s1">&#39;ObjectTransaction&#39;</span><span
        class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span
        class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span
        class="kc">None</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span
        class="n">transaction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_value</span> <span class="o">=</span> <span
        class="n">count_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span
        class="s1">&#39;count&#39;</span></div>


<div class="viewcode-block" id="CountResultPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan.execute">[docs]</a>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span
        class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span
        class="nb">dict</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;count&#39;</span><span
        class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_value</span><span
        class="p">}]</span></div>


<div class="viewcode-block" id="CountResultPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan.optimize">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span
        class="s1">&#39;QueryPlan&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span
        class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>

</pre>
                        </div>

                    </div>
                </div>
                <footer>

                    <hr/>

                    <div role="contentinfo">
                        <p>&#169; Copyright 2023, ProtoBase Team.</p>
                    </div>

                    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
                    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
                    provided by <a href="https://readthedocs.org">Read the Docs</a>.


                </footer>
            </div>
        </div>
    </section>
</div>
<script>
    jQuery(function () {
        SphinxRtdTheme.Navigation.enable(true);
    });
</script>

</body>
</html>