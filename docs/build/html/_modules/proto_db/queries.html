

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>proto_db.queries &mdash; ProtoBase 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ProtoBase
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced_usage.html">Advanced Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ProtoBase</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">proto_db.queries</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for proto_db.queries</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">cast</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">QueryPlan</span><span class="p">,</span> <span class="n">AtomPointer</span><span class="p">,</span> <span class="n">DBObject</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.db_access</span><span class="w"> </span><span class="kn">import</span> <span class="n">ObjectTransaction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.dictionaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">RepeatedKeysDictionary</span><span class="p">,</span> <span class="n">Dictionary</span><span class="p">,</span> <span class="n">DictionaryItem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">ProtoValidationException</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.hybrid_executor</span><span class="w"> </span><span class="kn">import</span> <span class="n">HybridExecutor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.sets</span><span class="w"> </span><span class="kn">import</span> <span class="n">Set</span>

<span class="c1"># Executor for async operations</span>
<span class="n">max_workers</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span>
<span class="n">executor_pool</span> <span class="o">=</span> <span class="n">HybridExecutor</span><span class="p">(</span><span class="n">base_num_workers</span><span class="o">=</span><span class="n">max_workers</span> <span class="o">//</span> <span class="mi">5</span><span class="p">,</span> <span class="n">sync_multiplier</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Expression</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for all expression types used to filter or match records.</span>

<span class="sd">    Expressions represent logical conditions that can be applied to records, such as</span>
<span class="sd">    &quot;and&quot;, &quot;or&quot;, &quot;not&quot;, or specific comparisons (terms). Subclasses must implement</span>
<span class="sd">    the `match` method to define their behavior for evaluating a record.</span>

<span class="sd">    The `Expression` structure is highly flexible and supports composition of multiple</span>
<span class="sd">    logical operators for complex filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="n">expression</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile a nested list of expressions into an `Expression` object.</span>

<span class="sd">        The method parses a structured list, where operators (`!`, `&amp;`, and `|`)</span>
<span class="sd">        and terms are used to build a tree of expressions (e.g., AndExpression,</span>
<span class="sd">        OrExpression, etc.). These compiled objects can then be used to evaluate</span>
<span class="sd">        whether a record satisfies the given conditions.</span>

<span class="sd">        :param expression: A nested list representing logical operations and terms.</span>
<span class="sd">        :type expression: list</span>
<span class="sd">        :return: A fully compiled `Expression` instance.</span>
<span class="sd">        :rtype: Expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Expression</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!&#39;</span><span class="p">:</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">following_expression</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">NotExpression</span><span class="p">(</span><span class="n">following_expression</span><span class="p">),</span> <span class="n">local_index</span>
            <span class="k">elif</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">first_operand</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="n">second_operand</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">AndExpression</span><span class="p">([</span><span class="n">first_operand</span><span class="p">,</span> <span class="n">second_operand</span><span class="p">]),</span> <span class="n">local_index</span>
            <span class="k">elif</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
                <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">first_operand</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="n">second_operand</span><span class="p">,</span> <span class="n">local_index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">local_index</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">OrExpression</span><span class="p">([</span><span class="n">first_operand</span><span class="p">,</span> <span class="n">second_operand</span><span class="p">]),</span> <span class="n">local_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Support nested sub-expressions and plain terms.</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span>
                <span class="c1"># If current token is a nested expression (list), compile it recursively</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">compiled</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                    <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">return</span> <span class="n">compiled</span><span class="p">,</span> <span class="n">local_index</span>
                <span class="c1"># Otherwise, it should be a plain term in prefix stream: [attr, op, value?]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">attr</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span>
                    <span class="n">op_token</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Invalid term at position </span><span class="si">{</span><span class="n">local_index</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">expression</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">operand</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">get_operator</span><span class="p">(</span><span class="n">op_token</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">operand</span><span class="o">.</span><span class="n">parameter_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">2</span>
                    <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">local_index</span>
                <span class="k">elif</span> <span class="n">operand</span><span class="o">.</span><span class="n">parameter_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Operand </span><span class="si">{</span><span class="n">op_token</span><span class="si">}</span><span class="s1"> expects binary term [attr, op, value]&#39;</span><span class="p">)</span>
                    <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">3</span>
                    <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">local_index</span>
                <span class="k">elif</span> <span class="n">operand</span><span class="o">.</span><span class="n">parameter_count</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lo</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="n">hi</span> <span class="o">=</span> <span class="n">expression</span><span class="p">[</span><span class="n">local_index</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Operand </span><span class="si">{</span><span class="n">op_token</span><span class="si">}</span><span class="s1"> expects ternary term [attr, op, lo, hi]&#39;</span><span class="p">)</span>
                    <span class="n">local_index</span> <span class="o">+=</span> <span class="mi">4</span>
                    <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)),</span> <span class="n">local_index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Unsupported parameter_count=</span><span class="si">{</span><span class="n">operand</span><span class="o">.</span><span class="n">parameter_count</span><span class="si">}</span><span class="s1"> for operator </span><span class="si">{</span><span class="n">op_token</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">default_and_expression</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
            <span class="n">new_expression</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">collect_expression</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">default_and_expression</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_expression</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">default_and_expression</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">default_and_expression</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default_and_expression</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">filter_by_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Term</span><span class="p">):</span>
            <span class="n">atribute_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_attribute</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">atribute_alias</span> <span class="ow">in</span> <span class="n">alias</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TrueTerm</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
            <span class="n">new_operands</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="n">new_operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">filter_by_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">new_operands</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
            <span class="c1"># OR cannot be safely pushed down by alias without full context; return neutral TrueTerm</span>
            <span class="k">return</span> <span class="n">TrueTerm</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">NotExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">NotExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">negated_expression</span><span class="o">.</span><span class="n">filter_by_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;It&#39;s not possible to filter </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> expression by alias!&quot;</span>
            <span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matches a given record against specific criteria defined by the implementation.</span>

<span class="sd">        This method is abstract and must be implemented by a subclass to provide the</span>
<span class="sd">        logic for determining whether the provided record satisfies the required</span>
<span class="sd">        conditions. The exact nature of the matching depends on the subclass</span>
<span class="sd">        implementation.</span>

<span class="sd">        :param record: The record to be evaluated.</span>
<span class="sd">        :type record: Any</span>
<span class="sd">        :return: A boolean value indicating whether the record matches the criteria.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AndExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logical &#39;AND&#39; expression for combining multiple conditions.</span>

<span class="sd">    Evaluates as True only if all terms in the `terms` list evaluate to True for a record.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - terms (list[Expression]): Sub-expressions that must all evaluate as True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate if the given record matches all sub-term conditions.</span>

<span class="sd">        :param record: The input record to evaluate.</span>
<span class="sd">        :type record: Any</span>
<span class="sd">        :return: True if all terms match the record, False otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">OrExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expression</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NotExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="n">negated_expression</span><span class="p">:</span> <span class="n">Expression</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">negated_expression</span><span class="p">:</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negated_expression</span> <span class="o">=</span> <span class="n">negated_expression</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">negated_expression</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Operator</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for comparison operators.</span>

<span class="sd">    Operators define how a source value should be compared to another value</span>
<span class="sd">    to produce a boolean result. Subclasses implement different kinds of</span>
<span class="sd">    comparisons, such as equality, inequality, or inclusion.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - parameter_count (int): The number of parameters this operator expects for comparison.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_operator</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method to get an operator instance based on a string representation.</span>

<span class="sd">        This allows dynamic resolution of operator behavior (e.g., &#39;==&#39;, &#39;!=&#39;, &#39;contains&#39;)</span>
<span class="sd">        at runtime. If the operator string is not recognized, an exception is raised.</span>

<span class="sd">        :param string: The string representation of the operator (e.g., &#39;==&#39;, &#39;in&#39;).</span>
<span class="sd">        :type string: str</span>
<span class="sd">        :return: An instance of a subclass of `Operator`.</span>
<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;==&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Equal</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;!=&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NotEqual</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Greater</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GreaterOrEqual</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lower</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LowerOrEqual</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;contains&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Contains</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">In</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?T&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IsTrue</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?!T&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NotTrue</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?N&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IsNone</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;?!N&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NotNone</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;between[]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Between</span><span class="p">(</span><span class="n">include_lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;between()&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Between</span><span class="p">(</span><span class="n">include_lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;between(]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Between</span><span class="p">(</span><span class="n">include_lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;between[)&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Between</span><span class="p">(</span><span class="n">include_lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;near[]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Near</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Unknown operator: </span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="s1">!&#39;</span>
            <span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is an abstract method that should be implemented in derived</span>
<span class="sd">        classes. It is designed to match the provided source against a specific</span>
<span class="sd">        value and return a result based on this matching process. The exact</span>
<span class="sd">        implementation and criteria of the match are dependent on the</span>
<span class="sd">        implementation in the subclass.</span>

<span class="sd">        :param source: The primary input against which the matching process</span>
<span class="sd">            will be performed. The exact nature of &#39;source&#39; depends on the</span>
<span class="sd">            implementation in the subclass.</span>
<span class="sd">        :param value: Optional value against which &#39;source&#39; will be matched.</span>
<span class="sd">            If not provided, the behavior may vary based on the subclass</span>
<span class="sd">            implementation.</span>
<span class="sd">        :return: The result of the matching process. The exact type and</span>
<span class="sd">            content of the returned value depend on the specific implementation</span>
<span class="sd">            in the subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Equal</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">==</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NotEqual</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">!=</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Greater</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&gt;</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GreaterOrEqual</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&gt;=</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Lower</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LowerOrEqual</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="o">&lt;=</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Contains</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">source</span>


<span class="k">class</span><span class="w"> </span><span class="nc">In</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">IsTrue</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NotTrue</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">IsNone</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NotNone</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>


<div class="viewcode-block" id="Between">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.Between">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Between</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Range comparison operator with configurable bound inclusivity.</span>
<span class="sd">    `value` must be a tuple (lo, hi).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<div class="viewcode-block" id="Between.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.Between.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">include_upper</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span> <span class="o">=</span> <span class="n">include_lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">=</span> <span class="n">include_upper</span></div>


<div class="viewcode-block" id="Between.match">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.Between.match">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">hi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># If lo &gt; hi, consider empty set (no match)</span>
            <span class="k">if</span> <span class="n">lo</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Lower bound</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Upper bound</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&gt;=</span> <span class="n">hi</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Non-comparable types -&gt; no match</span>
            <span class="k">return</span> <span class="kc">False</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">Near</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Similarity threshold operator for vector fields.</span>
<span class="sd">    Usage in Expression.compile: [&#39;field&#39;, &#39;near[]&#39;, query_vector, threshold]</span>
<span class="sd">    - value is treated as a tuple (query_vector, threshold)</span>
<span class="sd">    - metric defaults to cosine</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parameter_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;cosine&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">query_vec</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Accept both plain lists and Vector objects</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.vectors</span><span class="w"> </span><span class="kn">import</span> <span class="n">Vector</span><span class="p">,</span> <span class="n">cosine_similarity</span><span class="p">,</span> <span class="n">l2_distance</span>
            <span class="c1"># Extract raw data for source</span>
            <span class="n">src</span> <span class="o">=</span> <span class="n">source</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
                <span class="n">src_iter</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">src_iter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;cosine&#39;</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">cosine_similarity</span><span class="p">(</span><span class="n">src_iter</span><span class="p">,</span> <span class="n">query_vec</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_vec</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="k">else</span> <span class="n">query_vec</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;l2&#39;</span><span class="p">:</span>
                <span class="c1"># For l2, interpret threshold as max distance</span>
                <span class="c1"># Near should be distance &lt;= threshold</span>
                <span class="c1"># Use -distance as score if needed elsewhere</span>
                <span class="c1"># Compute distance</span>
                <span class="c1"># Reuse cosine helpers module for l2</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">.vectors</span><span class="w"> </span><span class="kn">import</span> <span class="n">l2_distance</span> <span class="k">as</span> <span class="n">_l2</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">_l2</span><span class="p">(</span><span class="n">src_iter</span><span class="p">,</span> <span class="n">query_vec</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_vec</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="k">else</span> <span class="n">query_vec</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Term</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="n">target_attribute</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">operation</span><span class="p">:</span> <span class="n">Operator</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">object</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">operation</span><span class="p">:</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_attribute</span> <span class="o">=</span> <span class="n">target_attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operation</span> <span class="o">=</span> <span class="n">operation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="c1"># Support dotted-paths and dict/DBObject records</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">resolve</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cur</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">cur</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">cur</span>
        <span class="n">source_value</span> <span class="o">=</span> <span class="n">resolve</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_attribute</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operation</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">source_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TrueTerm</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">FalseTerm</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="ListPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ListPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a QueryPlan from a python list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_list</span><span class="p">:</span> <span class="nb">list</span>

<div class="viewcode-block" id="ListPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">base_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_list</span> <span class="o">=</span> <span class="n">base_list</span></div>


<div class="viewcode-block" id="ListPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_list</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span></div>


<div class="viewcode-block" id="ListPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.ListPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">IndexedQueryPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IndexedQueryPlan is a specialized version of QueryPlan.</span>

<span class="sd">    It provides functionality for creating and managing indexed query plans</span>
<span class="sd">    that optimize query execution based on indexed data sources. This class</span>
<span class="sd">    extends the base functionality of QueryPlan to incorporate the use of</span>
<span class="sd">    indices in query operations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="n">Dictionary</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">:</span> <span class="n">Dictionary</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span> <span class="k">if</span> <span class="n">indexes</span> <span class="k">else</span> <span class="n">Dictionary</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IndexedQueryPlan</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an index to the database for optimizing query performance on specified columns. This method</span>
<span class="sd">        creates a new index with the given name on the columns specified in the list. Indexing can</span>
<span class="sd">        significantly improve the efficiency of certain queries, particularly for large datasets.</span>

<span class="sd">        :param field_name: field the index will be created on</span>
<span class="sd">        :return: An indexed query plan that contains details of the created index and its application</span>
<span class="sd">                 to the underlying query structure.</span>
<span class="sd">        :rtype: IndexedQueryPlan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">field_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Reindex the current content on the added field</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">RepeatedKeysDictionary</span><span class="p">(</span><span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">field_name</span><span class="p">):</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="n">field_name</span><span class="p">],</span> <span class="n">record</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">new_index</span><span class="p">),</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update_indexes_on_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">removed_record</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IndexedQueryPlan</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update indexes when specific data is removed from a collection or database.</span>

<span class="sd">        This function updates the internal indexes to maintain consistency</span>
<span class="sd">        after the specified data is removed. It ensures that subsequent</span>
<span class="sd">        queries reflect the correct indexed structure.</span>

<span class="sd">        :param removed_record: The data item that was removed, for which the</span>
<span class="sd">            indexes need to be updated.</span>
<span class="sd">        :return: An updated query plan reflecting the state of indexes</span>
<span class="sd">            after the removal.</span>
<span class="sd">        :rtype: IndexedQueryPlan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">RepeatedKeysDictionary</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">removed_record</span><span class="p">[</span><span class="n">field_name</span><span class="p">]:</span>
                <span class="n">new_indexes</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">remove_record_at</span><span class="p">(</span><span class="n">removed_record</span><span class="p">[</span><span class="n">field_name</span><span class="p">],</span> <span class="n">removed_record</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">new_indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update_indexes_on_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">added_record</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IndexedQueryPlan</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the indexed query plan when an item is added to the dataset.</span>

<span class="sd">        The method ensures that the internal indexes are recalibrated after</span>
<span class="sd">        removing any existing data that would conflict with the new item&#39;s</span>
<span class="sd">        location or plan alignment in the indexed structure. It recalculates</span>
<span class="sd">        and returns the updated query plan that reflects the modifications.</span>

<span class="sd">        :param added_record: the added data.</span>
<span class="sd">        :return: The updated IndexedQueryPlan object after modification to</span>
<span class="sd">            reflect changes caused by the addition operation.</span>
<span class="sd">        :rtype: IndexedQueryPlan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">RepeatedKeysDictionary</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">added_record</span><span class="p">[</span><span class="n">field_name</span><span class="p">]:</span>
                <span class="n">new_indexes</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">added_record</span><span class="p">[</span><span class="n">field_name</span><span class="p">],</span> <span class="n">added_record</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">IndexedQueryPlan</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">new_indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">position_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">])</span>

            <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

                <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">center</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">item</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">center</span>

                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">value</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;No index on field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s1">!&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">yield_from_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_greater_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_from_index</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_greater_or_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_from_index</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;No index on field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s1">!&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">yield_up_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">index_up_to</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">index_up_to</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_lower_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_up_to_index</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_lower_or_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_up_to_index</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">lo</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">include_lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">include_upper</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate records whose indexed key is within [lo, hi] with bound inclusivity flags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">field_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;No index on field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
        <span class="c1"># Find start position</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">lo</span><span class="p">)</span>
        <span class="c1"># Adjust for exclusive lower if exact match</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">lo</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_lower</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Iterate until passing upper bound</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">start</span>
        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">key</span>
            <span class="c1"># Stop based on upper bound</span>
            <span class="k">if</span> <span class="n">include_upper</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="n">hi</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">value_set</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">class</span><span class="w"> </span><span class="nc">IndexedSearchPlan</span><span class="p">(</span><span class="n">IndexedQueryPlan</span><span class="p">):</span>
    <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">:</span> <span class="n">Dictionary</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span>
            <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">field_to_scan</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;The field to scan should be specified!&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">operator</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;The operator should be specified!&#39;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span> <span class="o">=</span> <span class="n">field_to_scan</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="p">(</span>
                <span class="n">Lower</span><span class="p">,</span> <span class="n">LowerOrEqual</span><span class="p">,</span> <span class="n">Equal</span><span class="p">,</span> <span class="n">GreaterOrEqual</span><span class="p">,</span> <span class="n">Greater</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">ProtoValidationException</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;The operator is not valid (</span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s1">)!&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Equal</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Greater</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_greater_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">GreaterOrEqual</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_greater_or_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Lower</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lower_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">LowerOrEqual</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lower_or_equal_than</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">IndexedSearchPlan</span><span class="p">(</span>
            <span class="n">field_to_scan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast count leveraging indexes when possible.</span>
<span class="sd">        - For equality over an indexed field, return the set count directly.</span>
<span class="sd">        - Otherwise, fallback to executing and counting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Equal</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dictionary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">])</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DictionaryItem</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>
                <span class="n">value_set</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">value_set</span><span class="o">.</span><span class="n">count</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># On any unexpected shape, fallback to generic count</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AndMerge</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
    <span class="n">and_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">and_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span> <span class="o">=</span> <span class="n">and_queries</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">accumulators</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">)):</span>
            <span class="n">accumulators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">record</span> <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">execute</span><span class="p">()]))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">accumulators</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="n">record</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">accumulators</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">accumulators</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">accumulators</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">AndMerge</span><span class="p">(</span>
            <span class="n">and_queries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the count of the intersection of sub-queries.</span>
<span class="sd">        It optimizes by iterating the smaller result set and checking for</span>
<span class="sd">        existence in the larger one, without materializing full objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Optimize sub-queries first</span>
        <span class="n">optimized_queries</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">and_queries</span><span class="p">]</span>

        <span class="c1"># Get iterators of IDs, not full objects</span>
        <span class="n">id_iterators</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">keys_iterator</span><span class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">optimized_queries</span><span class="p">]</span>

        <span class="c1"># Sort by potential size (if a count() method is available)</span>
        <span class="n">id_iterators</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">it</span><span class="p">:</span> <span class="n">it</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>

        <span class="c1"># Use the smallest set as the base for iteration</span>
        <span class="n">base_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">id_iterators</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">base_ids</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Intersect with the other sets</span>
        <span class="k">for</span> <span class="n">other_iterator</span> <span class="ow">in</span> <span class="n">id_iterators</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">base_ids</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">other_iterator</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base_ids</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">base_ids</span><span class="p">)</span>


<div class="viewcode-block" id="IndexedRangeSearchPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IndexedRangeSearchPlan</span><span class="p">(</span><span class="n">IndexedQueryPlan</span><span class="p">):</span>
    <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">include_lower</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">include_upper</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">lo</span><span class="p">:</span> <span class="nb">object</span>
    <span class="n">hi</span><span class="p">:</span> <span class="nb">object</span>

<div class="viewcode-block" id="IndexedRangeSearchPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_to_scan</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">include_lower</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">include_upper</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                 <span class="n">indexes</span><span class="p">:</span> <span class="n">Dictionary</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span> <span class="o">=</span> <span class="n">field_to_scan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">=</span> <span class="n">lo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hi</span> <span class="o">=</span> <span class="n">hi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span> <span class="o">=</span> <span class="n">include_lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">=</span> <span class="n">include_upper</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If no indexes available, fallback to scanning based_on</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">,</span> <span class="n">IndexedQueryPlan</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
            <span class="c1"># Fallback should not normally happen if optimizer set this, but guard anyway</span>
            <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">rec</span>
            <span class="k">return</span>
        <span class="c1"># Use index range</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">IndexedRangeSearchPlan</span><span class="p">(</span>
            <span class="n">field_to_scan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field_to_scan</span><span class="p">,</span>
            <span class="n">lo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="p">,</span>
            <span class="n">hi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hi</span><span class="p">,</span>
            <span class="n">include_lower</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span><span class="p">,</span>
            <span class="n">include_upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="IndexedRangeSearchPlan.count">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.IndexedRangeSearchPlan.count">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">OrMerge</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
    <span class="n">or_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">or_queries</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QueryPlan</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span> <span class="o">=</span> <span class="n">or_queries</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">record</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">OrMerge</span><span class="p">(</span>
            <span class="n">or_queries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the count of the union of sub-queries.</span>
<span class="sd">        Prefer fast path with keys_iterator() when available; otherwise fall back to</span>
<span class="sd">        executing the plans and counting unique results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">optimized_queries</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_queries</span><span class="p">]</span>

        <span class="n">all_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">optimized_queries</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s1">&#39;keys_iterator&#39;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">keys_iterator</span><span class="p">():</span>
                        <span class="n">all_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># Fallback to execute</span>
                    <span class="k">pass</span>
            <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
                <span class="n">all_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_ids</span><span class="p">)</span>


<div class="viewcode-block" id="FromPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FromPlan</span><span class="p">(</span><span class="n">IndexedQueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span>

<div class="viewcode-block" id="FromPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">indexes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">RepeatedKeysDictionary</span><span class="p">],</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alias</span> <span class="ow">and</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">{</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">indexes</span>
                <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">indexes</span> <span class="ow">in</span> <span class="n">indexes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="n">alias</span></div>


<div class="viewcode-block" id="FromPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">DBObject</span><span class="p">(</span>
                <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">field_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">result</span></div>


<div class="viewcode-block" id="FromPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.FromPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FromPlan</span><span class="p">(</span>
            <span class="n">alias</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">),</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WherePlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WherePlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Query plan for filtering records based on an expression.</span>

<span class="sd">    This plan evaluates each record from the underlying `based_on` query plan</span>
<span class="sd">    against a filtering expression (`filter`). Records that satisfy the expression</span>
<span class="sd">    are passed downstream.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - filter (Expression): An expression determining which records to retain.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">filter</span><span class="p">:</span> <span class="n">Expression</span>

<div class="viewcode-block" id="WherePlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">filter_spec</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="nb">filter</span><span class="p">:</span> <span class="n">Expression</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_spec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">filter_spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">filter</span></div>


<div class="viewcode-block" id="WherePlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the filtering logic over the input records.</span>

<span class="sd">        Optimized path:</span>
<span class="sd">        - If the filter is an AndExpression and the underlying plan exposes indexes</span>
<span class="sd">          (IndexedQueryPlan), build candidate sets for indexable terms (==, in, contains,</span>
<span class="sd">          between, &lt;, &lt;=, &gt;, &gt;=) using the index, sort by selectivity (len), and intersect</span>
<span class="sd">          progressively. Then apply residual filtering on the reduced set only.</span>
<span class="sd">        - Otherwise, fallback to linear scan.</span>

<span class="sd">        :return: A generator yielding filtered records.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Attempt index-aware evaluation for AND conditions</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">Between</span> <span class="k">as</span> <span class="n">_Between</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">Equal</span> <span class="k">as</span> <span class="n">_Equal</span><span class="p">,</span> <span class="n">In</span> <span class="k">as</span> <span class="n">_In</span><span class="p">,</span> <span class="n">Contains</span> <span class="k">as</span> <span class="n">_Contains</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">Greater</span> <span class="k">as</span> <span class="n">_Greater</span><span class="p">,</span> <span class="n">GreaterOrEqual</span> <span class="k">as</span> <span class="n">_GreaterOrEqual</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">Lower</span> <span class="k">as</span> <span class="n">_Lower</span><span class="p">,</span> <span class="n">LowerOrEqual</span> <span class="k">as</span> <span class="n">_LowerOrEqual</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span>
        <span class="n">flt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">build_candidate_set</span><span class="p">(</span><span class="n">term</span><span class="p">:</span> <span class="n">Term</span><span class="p">):</span>
            <span class="c1"># Only terms with target attribute present in indexes are eligible</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">field</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">target_attribute</span>
                <span class="c1"># Ensure we have an IndexedQueryPlan and an index for the field</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">IndexedQueryPlan</span> <span class="k">as</span> <span class="n">_IQP</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">_IQP</span><span class="p">)</span> <span class="ow">or</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;indexes&#39;</span><span class="p">,</span> <span class="p">{}):</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">operation</span>
                <span class="c1"># Equality</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">_Equal</span><span class="p">):</span>
                    <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span><span class="p">:</span>
                        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="c1"># item is a Set; turn into Python set of records</span>
                    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">())</span>
                <span class="c1"># IN operator: union of equalities</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">_In</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">term</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                            <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
                            <span class="n">it</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">it</span><span class="p">:</span>
                                <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">())</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="k">return</span> <span class="n">result</span>
                <span class="c1"># CONTAINS: treat as equality on elements if index was built for contained elements</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">_Contains</span><span class="p">):</span>
                    <span class="n">idx_dict</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
                    <span class="n">it</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="o">.</span><span class="n">get_at</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">it</span><span class="p">:</span>
                        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">as_iterable</span><span class="p">())</span>
                    <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
                <span class="c1"># BETWEEN (range)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">_Between</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">lo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">hi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="c1"># Use indexed range helper to avoid scanning all</span>
                    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">get_range</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">include_lower</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">include_upper</span><span class="p">))</span>
                <span class="c1"># Greater/Less family as ranges</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">_Greater</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">get_greater_than</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">_GreaterOrEqual</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">get_greater_or_equal_than</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">_Lower</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">get_lower_than</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">_LowerOrEqual</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">get_lower_or_equal_than</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Only attempt when filter is a conjunction of terms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flt</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
            <span class="n">candidate_sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># keep full filter for safety; residual list reserved for future split</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">flt</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Term</span><span class="p">):</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="n">build_candidate_set</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">residual</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">candidate_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">residual</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">candidate_sets</span><span class="p">:</span>
                <span class="c1"># Order by selectivity (ascending size)</span>
                <span class="n">candidate_sets</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="c1"># Progressive intersection with early exit</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">candidate_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">candidate_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">current</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">current</span><span class="p">:</span>
                    <span class="k">return</span>  <span class="c1"># empty generator</span>
                <span class="c1"># Apply residual/full filter on reduced set only</span>
                <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">current</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">rec</span><span class="p">):</span>
                            <span class="k">yield</span> <span class="n">rec</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="c1"># Be conservative: if matching fails, skip</span>
                        <span class="k">pass</span>
                <span class="k">return</span>

        <span class="c1"># Fallback: linear scan</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">flt</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">record</span></div>


<div class="viewcode-block" id="WherePlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.WherePlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimizes the current execution plan node.</span>

<span class="sd">        This method is a core part of the query optimizer. It applies several</span>
<span class="sd">        strategies to transform the query plan into a more efficient equivalent.</span>
<span class="sd">        The primary optimizations include:</span>
<span class="sd">        1.  Filter Reordering: For AND expressions, reorder predicates to execute</span>
<span class="sd">            the most selective and least expensive ones first.</span>
<span class="sd">        2.  Predicate Pushdown: Attempt to move the filter logic (&quot;predicate&quot;)</span>
<span class="sd">            further down the execution tree, closer to the data source. This</span>
<span class="sd">            reduces the volume of data processed in upstream operators (like Joins).</span>
<span class="sd">        3.  Index Utilization: If a predicate can be satisfied using an index,</span>
<span class="sd">            transform this plan node into an `IndexedSearchPlan`.</span>

<span class="sd">        Args:</span>
<span class="sd">            full_plan: The root of the entire query plan, providing context if needed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An optimized `QueryPlan`, which may be a different type of node</span>
<span class="sd">            (e.g., `IndexedSearchPlan`) or a reconfigured `WherePlan`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, recursively optimize the source plan upon which this filter operates.</span>
        <span class="n">optimized_based_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">)</span>

        <span class="c1"># 1. FILTER REORDERING</span>
        <span class="c1"># For composite AND expressions, reorder the terms based on a cost/selectivity</span>
        <span class="c1"># heuristic. This ensures that cheaper and more selective predicates are</span>
        <span class="c1"># evaluated first, potentially short-circuiting the evaluation early.</span>
        <span class="n">current_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_filter</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
            <span class="n">current_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reorder_and_expression</span><span class="p">(</span><span class="n">current_filter</span><span class="p">)</span>

        <span class="c1"># 2. PREDICATE PUSHDOWN</span>
        <span class="c1"># Attempt to &quot;push&quot; this where clause down to the underlying plan node.</span>
        <span class="c1"># If the underlying node has an `accept_filter` method, it means it can</span>
        <span class="c1"># integrate the filter more efficiently (e.g., a JoinPlan applying it</span>
        <span class="c1"># pre-join, or a FromPlan applying it at the storage access level).</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">optimized_based_on</span><span class="p">,</span> <span class="s1">&#39;accept_filter&#39;</span><span class="p">):</span>
            <span class="c1"># The underlying plan will absorb the filter and return a new, optimized plan.</span>
            <span class="c1"># This `WherePlan` node can then be eliminated from the tree.</span>
            <span class="k">return</span> <span class="n">optimized_based_on</span><span class="o">.</span><span class="n">accept_filter</span><span class="p">(</span><span class="n">current_filter</span><span class="p">)</span>

        <span class="c1"># 3. INDEX UTILIZATION (the original optimization)</span>
        <span class="c1"># Check if the filter is a simple equality term that can be served by an index</span>
        <span class="c1"># on the underlying `IndexedQueryPlan`.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_filter</span><span class="p">,</span> <span class="n">Term</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_filter</span><span class="o">.</span><span class="n">operation</span><span class="p">,</span> <span class="n">Equal</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimized_based_on</span><span class="p">,</span> <span class="n">IndexedQueryPlan</span><span class="p">):</span>
                <span class="c1"># If the target attribute is indexed, replace this `WherePlan`</span>
                <span class="c1"># with a more efficient `IndexedSearchPlan`.</span>
                <span class="k">if</span> <span class="n">current_filter</span><span class="o">.</span><span class="n">target_attribute</span> <span class="ow">in</span> <span class="n">optimized_based_on</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">IndexedSearchPlan</span><span class="p">(</span>
                        <span class="n">field_to_scan</span><span class="o">=</span><span class="n">current_filter</span><span class="o">.</span><span class="n">target_attribute</span><span class="p">,</span>
                        <span class="n">operator</span><span class="o">=</span><span class="n">current_filter</span><span class="o">.</span><span class="n">operation</span><span class="p">,</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">current_filter</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">indexes</span><span class="o">=</span><span class="n">optimized_based_on</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
                        <span class="n">based_on</span><span class="o">=</span><span class="n">optimized_based_on</span><span class="p">,</span>
                        <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
                    <span class="p">)</span>
        <span class="c1"># Range pushdown for Between operators</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">Between</span> <span class="k">as</span> <span class="n">_Between</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_filter</span><span class="p">,</span> <span class="n">Term</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_filter</span><span class="o">.</span><span class="n">operation</span><span class="p">,</span> <span class="n">_Between</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimized_based_on</span><span class="p">,</span> <span class="n">IndexedQueryPlan</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">current_filter</span><span class="o">.</span><span class="n">target_attribute</span> <span class="ow">in</span> <span class="n">optimized_based_on</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
                    <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">current_filter</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_filter</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">lo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">IndexedRangeSearchPlan</span><span class="p">(</span>
                            <span class="n">field_to_scan</span><span class="o">=</span><span class="n">current_filter</span><span class="o">.</span><span class="n">target_attribute</span><span class="p">,</span>
                            <span class="n">lo</span><span class="o">=</span><span class="n">lo</span><span class="p">,</span>
                            <span class="n">hi</span><span class="o">=</span><span class="n">hi</span><span class="p">,</span>
                            <span class="n">include_lower</span><span class="o">=</span><span class="n">current_filter</span><span class="o">.</span><span class="n">operation</span><span class="o">.</span><span class="n">include_lower</span><span class="p">,</span>
                            <span class="n">include_upper</span><span class="o">=</span><span class="n">current_filter</span><span class="o">.</span><span class="n">operation</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
                            <span class="n">indexes</span><span class="o">=</span><span class="n">optimized_based_on</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
                            <span class="n">based_on</span><span class="o">=</span><span class="n">optimized_based_on</span><span class="p">,</span>
                            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
                        <span class="p">)</span>

        <span class="c1"># If no specific optimization could be applied, return a `WherePlan`</span>
        <span class="c1"># with the optimized base and the (potentially reordered) filter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="n">optimized_based_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">current_filter</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_reorder_and_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">and_expression</span><span class="p">:</span> <span class="s1">&#39;AndExpression&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;AndExpression&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts terms within an AndExpression based on a cost heuristic.</span>

<span class="sd">        The goal is to place less expensive and more selective terms at the</span>
<span class="sd">        beginning of the terms list. This allows the execution engine to</span>
<span class="sd">        reject non-matching records as early as possible.</span>

<span class="sd">        Args:</span>
<span class="sd">            and_expression: The AndExpression instance to reorder.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new AndExpression with the terms sorted according to the cost model.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_term_cost</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculates a cost for a filter term. A lower cost is better.</span>
<span class="sd">            This heuristic can be expanded to include index availability,</span>
<span class="sd">            cardinality estimates, etc.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Simple heuristic: equality checks are generally cheaper and more</span>
            <span class="c1"># selective than other operations.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Term</span><span class="p">)</span> <span class="ow">and</span> <span class="n">term</span><span class="o">.</span><span class="n">operation</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;==&#39;</span><span class="p">,</span> <span class="s1">&#39;eq&#39;</span><span class="p">]:</span>
                <span class="c1"># A check on an indexed field would ideally have a cost of 0.</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">10</span>  <span class="c1"># Represents a higher cost for other operations.</span>

        <span class="c1"># Sort the terms, placing the lowest-cost terms first.</span>
        <span class="n">sorted_terms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">and_expression</span><span class="o">.</span><span class="n">terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">get_term_cost</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="n">terms</span><span class="o">=</span><span class="n">sorted_terms</span><span class="p">)</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">AgreggatorFunction</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for aggregator functions.</span>

<span class="sd">    Aggregator functions perform operations (e.g., sum, average) over fields</span>
<span class="sd">    or records grouped under a common criteria. Each subclass implements</span>
<span class="sd">    its own logic for computing aggregate results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the aggregation over a list of values.</span>

<span class="sd">        :param values: A list of values to aggregate.</span>
<span class="sd">        :type values: list</span>
<span class="sd">        :return: The result of the aggregation.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SumAgreggator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum aggregator function for computing the sum of a list of numeric values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the total sum of the given numeric values.</span>

<span class="sd">        :param values: A list of numeric values.</span>
<span class="sd">        :type values: list[float|int]</span>
<span class="sd">        :return: The sum of all values in the list.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">total_sum</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">total_sum</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AvgAggregator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CountAggregator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MinAgreggator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">minimun</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">minimun</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">minimun</span><span class="p">:</span>
                <span class="n">minimun</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">minimun</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MaxAggregator</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An aggregator that finds the maximum value in a list of values.</span>

<span class="sd">    It initializes the maximum value to None and then iterates through the list,</span>
<span class="sd">    updating the maximum value whenever a larger value is found.</span>
<span class="sd">    It returns the overall maximum value. If the list is empty, it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the maximum value from a list of values.</span>

<span class="sd">        Args:</span>
<span class="sd">            values: The list of values to compute the maximum from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The maximum value in the list, or None if the list is empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">max_value</span><span class="p">:</span>
                <span class="n">max_value</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">max_value</span>


<div class="viewcode-block" id="UnnestPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.UnnestPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UnnestPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plan that flattens a collection from each input record.</span>
<span class="sd">    - source_path: dotted path string or callable(record) -&gt; iterable</span>
<span class="sd">    - element_alias: if provided, the element is attached to the original record under this key; otherwise the element replaces the record.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="UnnestPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.UnnestPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_path</span><span class="p">,</span> <span class="n">element_alias</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span> <span class="o">=</span> <span class="n">source_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span> <span class="o">=</span> <span class="n">element_alias</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">record</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">cur</span>

<div class="viewcode-block" id="UnnestPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.UnnestPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="c1"># determine the collection</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">collection</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_path</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">)</span>
            <span class="c1"># check iterability (avoid strings/bytes)</span>
            <span class="k">if</span> <span class="n">collection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem</span>
                        <span class="k">yield</span> <span class="n">out</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># assume DBObject-like</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">record</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="p">{</span><span class="o">**</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="s1">&#39;items&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}),</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_alias</span><span class="p">:</span> <span class="n">elem</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">elem</span></div>


<div class="viewcode-block" id="UnnestPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.UnnestPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="CollectionFieldPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CollectionFieldPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CollectionFieldPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each left record, executes a subplan built from it and attaches the collected results as a list under field_name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CollectionFieldPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CollectionFieldPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">subplan_builder</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">transaction</span><span class="p">:</span> <span class="n">ObjectTransaction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_name</span> <span class="o">=</span> <span class="n">field_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subplan_builder</span> <span class="o">=</span> <span class="n">subplan_builder</span></div>


<div class="viewcode-block" id="CollectionFieldPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CollectionFieldPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">left</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="n">subplan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subplan_builder</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subplan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subplan</span> <span class="o">=</span> <span class="n">subplan</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">subplan</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span>
                <span class="k">yield</span> <span class="n">out</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">left</span><span class="o">.</span><span class="n">_setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="s1">&#39;items&#39;</span><span class="p">):</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">left</span><span class="p">))</span>
                    <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span>
                    <span class="k">yield</span> <span class="n">out</span></div>


<div class="viewcode-block" id="CollectionFieldPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CollectionFieldPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="n">QueryPlan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryPlan</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="SelectPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SelectPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A query plan that selects and transforms fields from records produced by another query plan.</span>

<span class="sd">    This plan allows for both direct field mapping (renaming fields) and dynamic field</span>
<span class="sd">    generation through callable functions. It&#39;s useful for projecting and transforming</span>
<span class="sd">    data in a query pipeline.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SelectPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="n">QueryPlan</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="s1">&#39;ObjectTransaction&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atom_pointer</span><span class="p">:</span> <span class="n">AtomPointer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a SelectPlan with field mappings and a base query plan.</span>

<span class="sd">        Args:</span>
<span class="sd">            fields: A dictionary mapping output field names to either:</span>
<span class="sd">                   - Source field names (strings) for direct mapping</span>
<span class="sd">                   - Callable functions that take a record and return a value</span>
<span class="sd">            based_on: The query plan that produces the records to transform</span>
<span class="sd">            transaction: The transaction context</span>
<span class="sd">            atom_pointer: Pointer to the atom in storage</span>
<span class="sd">            **kwargs: Additional arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">,</span> <span class="n">atom_pointer</span><span class="o">=</span><span class="n">atom_pointer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">fields</span></div>


<div class="viewcode-block" id="SelectPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the plan, transforming records from the base plan according to field mappings.</span>

<span class="sd">        For each record from the base plan, this method creates a new record with fields</span>
<span class="sd">        mapped according to the field specification provided at initialization.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Transformed records with the specified field mappings applied.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Any exception that might be raised by callable field mappings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">output_field</span><span class="p">,</span> <span class="n">source_spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">source_spec</span><span class="p">):</span>
                    <span class="c1"># Dynamic field generation through a callable</span>
                    <span class="c1"># Let any exceptions propagate up to the caller</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">output_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_spec</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Direct field mapping</span>
                    <span class="c1"># Only include the field if it exists in the source record</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">source_spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">output_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">yield</span> <span class="n">result</span></div>


<div class="viewcode-block" id="SelectPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.SelectPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize this plan and its dependencies.</span>

<span class="sd">        This method delegates optimization to the underlying plan and then</span>
<span class="sd">        creates a new SelectPlan with the optimized base.</span>

<span class="sd">        Args:</span>
<span class="sd">            full_plan: The complete query plan for context</span>

<span class="sd">        Returns:</span>
<span class="sd">            An optimized version of this plan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">optimized_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">optimized_base</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">SelectPlan</span><span class="p">(</span>
            <span class="n">fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="n">optimized_base</span><span class="p">,</span>
            <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="CountPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CountPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A query plan that counts the results from a sub-plan.</span>
<span class="sd">    This plan is optimized to use index counts whenever possible,</span>
<span class="sd">    avoiding full data iteration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CountPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">based_on</span><span class="p">:</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="s1">&#39;ObjectTransaction&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the CountPlan.</span>

<span class="sd">        Args:</span>
<span class="sd">            based_on: The underlying plan whose results will be counted.</span>
<span class="sd">            transaction: The active transaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="s1">&#39;count&#39;</span></div>


<div class="viewcode-block" id="CountPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the count. If no optimization is possible,</span>
<span class="sd">        it iterates through the sub-plan&#39;s results and counts them.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list containing a single dictionary with the count, e.g., [{&#39;count&#39;: 123}].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">count</span><span class="p">}]</span></div>


<div class="viewcode-block" id="CountPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimizes the counting process.</span>

<span class="sd">        If the underlying plan can provide a count efficiently (e.g., it&#39;s an</span>
<span class="sd">        indexed search), this method will delegate the counting to it.</span>
<span class="sd">        Otherwise, it returns itself to perform a standard iteration count.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A plan that can provide the count, potentially a new optimized plan</span>
<span class="sd">            or itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optimized_based_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">full_plan</span><span class="p">)</span>

        <span class="c1"># Duck-typing: Check if the optimized underlying plan has a fast `count` method.</span>
        <span class="c1"># Only delegate if the method is overridden (not the default QueryPlan.count).</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">optimized_based_on</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Special-case: don&#39;t delegate for plain ListPlan (no fast path expected)</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">.queries</span><span class="w"> </span><span class="kn">import</span> <span class="n">ListPlan</span> <span class="k">as</span> <span class="n">_ListPlan</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimized_based_on</span><span class="p">,</span> <span class="n">_ListPlan</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Use default path for ListPlan&#39;</span><span class="p">)</span>
                <span class="c1"># Otherwise, delegate if a count method is present</span>
                <span class="k">return</span> <span class="n">CountResultPlan</span><span class="p">(</span><span class="n">count_value</span><span class="o">=</span><span class="n">optimized_based_on</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">transaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Fall through to default behavior</span>
                <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="n">optimized_based_on</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">ArrayAgg</span><span class="p">(</span><span class="n">AgreggatorFunction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aggregator that collects values into a list (array aggregation).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>


<div class="viewcode-block" id="CountResultPlan">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CountResultPlan</span><span class="p">(</span><span class="n">QueryPlan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A terminal plan that simply holds and returns a pre-calculated count.</span>
<span class="sd">    This is the result of an optimized CountPlan.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CountResultPlan.__init__">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_value</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">transaction</span><span class="p">:</span> <span class="s1">&#39;ObjectTransaction&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">based_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transaction</span><span class="o">=</span><span class="n">transaction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_value</span> <span class="o">=</span> <span class="n">count_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="s1">&#39;count&#39;</span></div>


<div class="viewcode-block" id="CountResultPlan.execute">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan.execute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_value</span><span class="p">}]</span></div>


<div class="viewcode-block" id="CountResultPlan.optimize">
<a class="viewcode-back" href="../../api/queries.html#proto_db.queries.CountResultPlan.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_plan</span><span class="p">:</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;QueryPlan&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, ProtoBase Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>